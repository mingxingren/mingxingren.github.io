<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenGL知识整理</title>
      <link href="/2021/12/22/opengl%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2021/12/22/opengl%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="winit-——-跨平台的窗口创建和管理"><a href="#winit-——-跨平台的窗口创建和管理" class="headerlink" title="winit —— 跨平台的窗口创建和管理"></a>winit —— 跨平台的窗口创建和管理</h4><p>glutin使用流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start=&gt;start: 开始</span><br><span class="line">op1=&gt;operation: 申请事件循环 EventLoop</span><br><span class="line">op2=&gt;operation: 创建窗口资源 WindowedContext</span><br><span class="line">op3=&gt;operation: 加载shader文件</span><br><span class="line">op4=&gt;operation: 调用 glCreateProgram 创建着色器程序容器</span><br><span class="line">end=&gt;end: 处理结束</span><br><span class="line"></span><br><span class="line">start-&gt;op1-&gt;op2-&gt;op3-&gt;op4-&gt;end</span><br></pre></td></tr></table></figure><h4 id="Opengl-Sharders（着色器）"><a href="#Opengl-Sharders（着色器）" class="headerlink" title="Opengl Sharders（着色器）"></a>Opengl Sharders（着色器）</h4><h5 id="顶点着色器的坐标系统"><a href="#顶点着色器的坐标系统" class="headerlink" title="顶点着色器的坐标系统"></a>顶点着色器的坐标系统</h5><p>顶点着色器的坐标很有意思,  它使用 -1 和 1表示坐标系轴方向上的负边界和正边界.  仔细想想确实应该如此，假使我们想渲染的一块区域的大小是 10x10大小的矩形，那么边界就是 -5 ~ 5，当区域是20x20时，边界便改为 -10~10. 我猜如果以确定边界绘制左边代码便不具有普适性，这个矩形尺寸调整一下，那个矩形尺寸调整一下. 所以统一用 -1 和 1表示边界值, 中间值乘以系数表示其他坐标点，这样就不用受到渲染矩形区域大小的影响.</p><p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021120501.png" alt="image-01"></p><p>着色器（<strong>Shader</strong>）是运行在GPU上的小程序，这些小程序为图形渲染管线的某个特定部分而运行。使用一种叫 <strong>GLSL</strong> 的类C语言写成，一个典型的着色器有下面的结构</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> type out_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="opengl相关库"><a href="#opengl相关库" class="headerlink" title="opengl相关库:"></a>opengl相关库:</h4><p>① glfw：负责创建窗口，上下文，纹理，输入输出、处理消息循环</p><p>② glew：用于加载 opengl 相关库加载</p><h4 id="opengl-参考资料"><a href="#opengl-参考资料" class="headerlink" title="opengl 参考资料"></a>opengl 参考资料</h4><p><a href="https://antongerdelan.net/opengl/index.html#onlinetuts">https://antongerdelan.net/opengl/index.html#onlinetuts</a></p><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p><h3 id="OpenGL-调用流程"><a href="#OpenGL-调用流程" class="headerlink" title="OpenGL 调用流程"></a>OpenGL 调用流程</h3><ol><li>着色器创建流程</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start=&gt;start: Start</span><br><span class="line">op_1=&gt;operation: glCreateShader 创建着器句柄</span><br><span class="line">op_2=&gt;operation: glShaderSource 加载着色器脚本</span><br><span class="line">op_3=&gt;operation: glCompileShader 编译着色器脚本</span><br><span class="line">op_4=&gt;operation: glGetShaderiv 判断着色器编译结果是否成功</span><br><span class="line">op_5=&gt;operation: glGetShaderInfoLog 获取着色器信息日志</span><br><span class="line">cond=&gt;condition: 是否成功</span><br><span class="line">end=&gt;end</span><br><span class="line">start-&gt;op_1-&gt;op_2-&gt;op_3-&gt;op_4-&gt;cond</span><br><span class="line">cond(yes)-&gt;end</span><br><span class="line">cond(no)-&gt;op_5-&gt;end</span><br></pre></td></tr></table></figure><ol start="2"><li>创建 OpenGL 工程对象</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start</span><br><span class="line">op_1=&gt;operation: glCreateProgram 创建工程对象</span><br><span class="line">op_2=&gt;operation: glAttachShader 加载顶点着色器,片段着色器</span><br><span class="line">op_3=&gt;operation: glLinkProgram 构建工程</span><br><span class="line">op_4=&gt;operation: glGetProgramiv 获取工程构建状态</span><br><span class="line">op_5=&gt;operation: glDeleteShader 删除着色器</span><br><span class="line">op_6=&gt;operation: glGetProgramInfoLog 获取工程日志</span><br><span class="line">cond=&gt;condition: 是否成功</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op_1-&gt;op_2-&gt;op_3-&gt;op_4-&gt;cond</span><br><span class="line">cond(yes)-&gt;op_5-&gt;e</span><br><span class="line">cond(no)-&gt;op_6-&gt;e</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>imgui接口说明文档</title>
      <link href="/2021/11/25/imgui%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/"/>
      <url>/2021/11/25/imgui%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Dear-Imgui-Ui部分的API说明"><a href="#Dear-Imgui-Ui部分的API说明" class="headerlink" title="Dear Imgui Ui部分的API说明"></a>Dear Imgui Ui部分的API说明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始新的一帧，可以提交任何指令直到调用 Render()/EndFrame()</span></span><br><span class="line"><span class="function">IMGUI_API <span class="keyword">void</span> <span class="title">NewFrame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 window 入栈并且开始调用命令修饰它，直到调用 End 让 window 出栈</span></span><br><span class="line"><span class="comment">// 当 bool *p_open！= NULL, 窗体右上角会有关闭选项, 点击这个选项会设置p_open为false</span></span><br><span class="line"><span class="comment">// 可以在同一帧调用多次 Begin()/End() 来对同一个窗体进行多次操作，前提是 name 相同</span></span><br><span class="line"><span class="comment">// 像 flags 或者 p_open 只在第一次调用 Begin() 起作用</span></span><br><span class="line"><span class="comment">// Begin() 返回 false 表示窗口已折叠或完全裁剪，因此可以提前退出并省略提交</span></span><br><span class="line"><span class="comment">// [重要提示: 由于遗留问题，这与大多数其他函数如 BeginMenu/EndMenu、BeginPopup/EndPopup 等不一致</span></span><br><span class="line"><span class="comment">// , 只有在相应的 BeginXXX函数返回 true 时才应调用 EndXXX 调用. Begin 和 BeginChild 是唯一奇数. </span></span><br><span class="line"><span class="comment">// 将在未来的更新中修复]</span></span><br><span class="line"><span class="comment">// 请注意，窗口堆栈的底部始终包含一个名为&quot;调试&quot;的窗口</span></span><br><span class="line"><span class="function">IMGUI_API <span class="keyword">bool</span> <span class="title">Begin</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">bool</span>* p_open = <span class="literal">NULL</span>, ImGuiWindowFlags flags = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ImGuiWindowFlags 说明</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ImGuiWindowFlags_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ImGuiWindowFlags_None                   = <span class="number">0</span>,</span><br><span class="line">    ImGuiWindowFlags_NoTitleBar             = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,   <span class="comment">// 禁用标题栏</span></span><br><span class="line">    ImGuiWindowFlags_NoResize               = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">// 禁止用户调整通过右下角调整大小</span></span><br><span class="line">    ImGuiWindowFlags_NoMove                 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,   <span class="comment">// 禁止用户移动窗体</span></span><br><span class="line">    ImGuiWindowFlags_NoScrollbar            = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,   <span class="comment">// 禁止滚动条 (window can still scroll with mouse or programmatically)</span></span><br><span class="line">    ImGuiWindowFlags_NoScrollWithMouse      = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,   <span class="comment">// 禁止用户使用鼠标滚轮垂直滚动. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.</span></span><br><span class="line">    ImGuiWindowFlags_NoCollapse             = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,   <span class="comment">// 禁止用户通过双击折叠窗口</span></span><br><span class="line">    ImGuiWindowFlags_AlwaysAutoResize       = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 窗体大小自适应每帧内容</span></span><br><span class="line">    ImGuiWindowFlags_NoBackground           = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,   <span class="comment">// 禁止画背景和边框. Similar as using SetNextWindowBgAlpha(0.0f).</span></span><br><span class="line">    ImGuiWindowFlags_NoSavedSettings        = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,   <span class="comment">// Never load/save settings in .ini file</span></span><br><span class="line">    ImGuiWindowFlags_NoMouseInputs          = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 禁止捕捉鼠标, hovering test with pass through.</span></span><br><span class="line">    ImGuiWindowFlags_MenuBar                = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  <span class="comment">// 有一个菜单栏</span></span><br><span class="line">    ImGuiWindowFlags_HorizontalScrollbar    = <span class="number">1</span> &lt;&lt; <span class="number">11</span>,  <span class="comment">// 允许有一个水平滚动条 (默认关闭). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the &quot;Horizontal Scrolling&quot; section.</span></span><br><span class="line">    ImGuiWindowFlags_NoFocusOnAppearing     = <span class="number">1</span> &lt;&lt; <span class="number">12</span>,  <span class="comment">// 从隐藏状态转换为可见状态时禁用获取焦点</span></span><br><span class="line">    ImGuiWindowFlags_NoBringToFrontOnFocus  = <span class="number">1</span> &lt;&lt; <span class="number">13</span>,  <span class="comment">// Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)</span></span><br><span class="line">    ImGuiWindowFlags_AlwaysVerticalScrollbar= <span class="number">1</span> &lt;&lt; <span class="number">14</span>,  <span class="comment">// 总是显示垂直滚动条(even if ContentSize.y &lt; Size.y)</span></span><br><span class="line">    ImGuiWindowFlags_AlwaysHorizontalScrollbar=<span class="number">1</span>&lt;&lt; <span class="number">15</span>,  <span class="comment">// 总是显示水平滚动条 (even if ContentSize.x &lt; Size.x)</span></span><br><span class="line">    ImGuiWindowFlags_AlwaysUseWindowPadding = <span class="number">1</span> &lt;&lt; <span class="number">16</span>,  <span class="comment">// 使用style.Window Padding 确保子窗体没有边框 (ignored by default for non-bordered child windows, because more convenient)</span></span><br><span class="line">    ImGuiWindowFlags_NoNavInputs            = <span class="number">1</span> &lt;&lt; <span class="number">18</span>,  <span class="comment">// 窗口内没有游戏手柄/键盘导航</span></span><br><span class="line">    ImGuiWindowFlags_NoNavFocus             = <span class="number">1</span> &lt;&lt; <span class="number">19</span>,  <span class="comment">// No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)</span></span><br><span class="line">    ImGuiWindowFlags_UnsavedDocument        = <span class="number">1</span> &lt;&lt; <span class="number">20</span>,  <span class="comment">// Display a dot next to the title. When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.</span></span><br><span class="line">    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,</span><br><span class="line">    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,</span><br><span class="line">    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [Internal]</span></span><br><span class="line">    ImGuiWindowFlags_NavFlattened           = <span class="number">1</span> &lt;&lt; <span class="number">23</span>,  <span class="comment">// [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)</span></span><br><span class="line">    ImGuiWindowFlags_ChildWindow            = <span class="number">1</span> &lt;&lt; <span class="number">24</span>,  <span class="comment">// Don&#x27;t use! For internal use by BeginChild()</span></span><br><span class="line">    ImGuiWindowFlags_Tooltip                = <span class="number">1</span> &lt;&lt; <span class="number">25</span>,  <span class="comment">// Don&#x27;t use! For internal use by BeginTooltip()</span></span><br><span class="line">    ImGuiWindowFlags_Popup                  = <span class="number">1</span> &lt;&lt; <span class="number">26</span>,  <span class="comment">// Don&#x27;t use! For internal use by BeginPopup()</span></span><br><span class="line">    ImGuiWindowFlags_Modal                  = <span class="number">1</span> &lt;&lt; <span class="number">27</span>,  <span class="comment">// Don&#x27;t use! For internal use by BeginPopupModal()</span></span><br><span class="line">    ImGuiWindowFlags_ChildMenu              = <span class="number">1</span> &lt;&lt; <span class="number">28</span>   <span class="comment">// Don&#x27;t use! For internal use by BeginMenu()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [Obsolete]</span></span><br><span class="line">    <span class="comment">//ImGuiWindowFlags_ResizeFromAnySide    = 1 &lt;&lt; 17,  // --&gt; Set io.ConfigWindowsResizeFromEdges=true and make sure mouse cursors are supported by backend (io.BackendFlags &amp; ImGuiBackendFlags_HasMouseCursors)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出框: 打开 / 关闭 功能</span></span><br><span class="line"><span class="comment">// - OpenPopup(): 设置弹出框为打开, ImGuiPopupFlags 可用于打开选项</span></span><br><span class="line"><span class="comment">// - If not modal: 通过点击其他地方关闭弹出框 或者 点击 ESCAPE</span></span><br><span class="line"><span class="comment">// - CloseCurrentPopup(): 在 BeginPopup 到 EndPopup 命令执行中，调用 CloseCurrentPopup 可以手动关闭, 当 Selectable()/MenuItem() 激活时, CloseCurrentPopup()默认被调用 </span></span><br><span class="line"><span class="comment">// - Use ImGuiPopupFlags_NoOpenOverExistingPopup to avoid opening a popup if there&#x27;s already one at the same level. This is equivalent to e.g. testing for !IsAnyPopupOpen() prior to OpenPopup().</span></span><br><span class="line"><span class="comment">// - 在BeginPopup() 之后使用 IsWindowAppearing() 判断窗口是否刚刚打开</span></span><br><span class="line"><span class="function">IMGUI_API <span class="keyword">void</span> <span class="title">OpenPopup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_id, ImGuiPopupFlags popup_flags = <span class="number">0</span>)</span></span>;<span class="comment">// call to mark popup as open (don&#x27;t call every frame!).</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出层, 模态</span></span><br><span class="line"><span class="comment">// - 会阻塞 调用 后面的鼠标悬停检测(以及大多数鼠标交互)</span></span><br><span class="line"><span class="comment">// - if not modal: 通过点击其他地方关闭弹出框 或者 点击 ESCAPE</span></span><br><span class="line"><span class="comment">// - 可见性状态 (~bool) 是在内部保存的, 并不是被调用者保存</span></span><br><span class="line"><span class="comment">// - 上面的三个属性是相关的: 我们需要在库中保留弹出窗口可见性状态，因为弹出窗口可能随时关闭</span></span><br><span class="line"><span class="comment">// - 可以调用 IsItemHovered() or IsWindowHovered() 时使用 ImGuiHoveredFlags_AllowWhenBlockedByPopup 来绕过悬停限制</span></span><br><span class="line"><span class="comment">// - 重要提示: Popup 标识符时相对于当前 ID 堆栈的, 因此 OpenPopup 和 BeginPopup 一般需要在堆栈的同一级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Popups: begin/end functions</span></span><br><span class="line"><span class="comment">// -BeginPopup(): 查询弹出状态, 如果打开就附加到 window. 之后调用 EndPopup(). ImGuiWindowFlags 被转发到window</span></span><br><span class="line"><span class="comment">// -BeginPopupModal():  block every interactions behind the window, cannot be closed by user, add a dimming background, has a title bar.</span></span><br><span class="line"><span class="function">IMGUI_API <span class="keyword">bool</span> <span class="title">BeginPopup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_id, ImGuiWindowFlags flags = <span class="number">0</span>)</span></span>;<span class="comment">// return true if the popup is open, and you can start outputting to it.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ imgui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rust知识整理</title>
      <link href="/2021/10/12/rust%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2021/10/12/rust%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ol><li>Rust 的克隆与复制</li></ol><p><a href="https://zhuanlan.zhihu.com/p/21730929">https://zhuanlan.zhihu.com/p/21730929</a></p><ol start="2"><li><p>Rust 提供了分层式处理错误方案：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Option</span>&lt;T&gt;: 用于处理有值和无值的情况</span><br><span class="line"><span class="built_in">Result</span>&lt;T, E&gt;: 用于处理可恢复错误的情况</span><br><span class="line">Panic: 用于处理不可恢复错误的情况</span><br><span class="line">Abort: 用于处理会发生灾难性后果的情况</span><br></pre></td></tr></table></figure></li><li><p>生命周期注解位于引用的 <strong>&amp;</strong> 操作符之后，并用一个空格将生命周期注解与引用类型分隔开，比如 <strong>&amp; ‘a i32</strong>  、 <strong>&amp;’a mut i32</strong>、**&amp;’a str** 。生周期注解并不改变任何引用的生命周期的大小，只用于描述多个生命周期间的关系。</p></li></ol><ol start="4"><li><p><strong>async</strong> 关键字作用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 1. 允许函数体内使用 .await 语法</span><br><span class="line">// 2. 修改函数的返回类型。 async fn foo() -&gt; Bar 实际上返回的是 impl std::future::Future&lt;Output=Bar&gt;</span><br><span class="line">// 3. 自动将返回值封装进一个新的 future 对象</span><br></pre></td></tr></table></figure><p><strong>.await</strong> 语法的作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p><strong>C/CPP Type to Rust</strong></p><p>参考：<a href="https://locka99.gitbooks.io/a-guide-to-porting-c-to-rust/content/features_of_rust/types.html">https://locka99.gitbooks.io/a-guide-to-porting-c-to-rust/content/features_of_rust/types.html</a></p><table><thead><tr><th align="center">C/C++</th><th align="center">Rust</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">i8(or u8)</td></tr><tr><td align="center">unsigned char</td><td align="center">u8</td></tr><tr><td align="center">signed char</td><td align="center">i8</td></tr><tr><td align="center">short int</td><td align="center">i16</td></tr><tr><td align="center">unsigned short int</td><td align="center">u16</td></tr><tr><td align="center">(signed)  int</td><td align="center">i32 or i16</td></tr><tr><td align="center">unsigned int</td><td align="center">u32 or u16</td></tr><tr><td align="center">(signed) long int</td><td align="center">i32<code>or</code>i64</td></tr><tr><td align="center">unsigned long int</td><td align="center">u32<code>or</code>u64</td></tr><tr><td align="center">(signed) long long int</td><td align="center">i64</td></tr><tr><td align="center">size_t</td><td align="center">usize</td></tr><tr><td align="center">float</td><td align="center">f32</td></tr><tr><td align="center">double</td><td align="center">f64</td></tr><tr><td align="center">long double</td><td align="center">f128<br />(Rust 在有些平台上不支持该类型)</td></tr><tr><td align="center">bool</td><td align="center">bool</td></tr><tr><td align="center">void</td><td align="center">()</td></tr></tbody></table><p>C 的 <code>&lt;stdin.h&gt;</code>  头文件提供具有长度签名的类型别名（推荐使用）</p><table><thead><tr><th align="center">C/CPP</th><th align="center">Rust</th></tr></thead><tbody><tr><td align="center">int8_t</td><td align="center">i8</td></tr><tr><td align="center">uint8_t</td><td align="center">u8</td></tr><tr><td align="center">int16_t</td><td align="center">i16</td></tr><tr><td align="center">uint16_t</td><td align="center">u16</td></tr><tr><td align="center">int32_t</td><td align="center">i32</td></tr><tr><td align="center">uint32_t</td><td align="center">u32</td></tr><tr><td align="center">int64_t</td><td align="center">i64</td></tr><tr><td align="center">uint64_t</td><td align="center">u64</td></tr></tbody></table><p>Rust FFI编程——手动绑定C库</p><p><a href="https://rustcc.cn/article?id=f70a81d1-cb79-4429-985c-d3d53247f5c0">https://rustcc.cn/article?id=f70a81d1-cb79-4429-985c-d3d53247f5c0</a></p></li></ol><ol start="6"><li><strong>rust 指针转换</strong></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust *mut u8 转换成 &amp;[u8]</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// data_ptr为 *mut u8, data为 &amp;[u8]</span></span><br><span class="line">    <span class="comment">// 使用 slice::from_raw_parts 不会发生拷贝，作用给这块内存创建一个切片</span></span><br><span class="line">    <span class="keyword">let</span> data = slice::from_raw_parts(data_ptr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rust *mut u8 转换成 &amp;mut [u8]</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// data_ptr为 *mut u8, data为 Vec[u8]</span></span><br><span class="line">    <span class="comment">// 使用 Vec::from_raw_parts 不会发生拷贝，该块内存的所有权会被 data 接管</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">Vec</span>::from_raw_parts(data_ptr, size, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.原始指针</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &amp;<span class="number">56</span>;</span><br><span class="line"><span class="keyword">let</span> a_raw_ptr = a <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u32</span>;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">let</span> b = &amp;<span class="keyword">mut</span> <span class="number">5634.3</span>;</span><br><span class="line"><span class="keyword">let</span> b_mut_ptr = b <span class="keyword">as</span> *<span class="keyword">mut</span> T;</span><br></pre></td></tr></table></figure><p>8.rust 智能指针</p><blockquote><ul><li>独占式智能指针 <code>Box&lt;T&gt;</code></li><li>非线程安全的引用计数智能指针 <code>Rc&lt;T&gt;</code></li><li>线程安全的引用计数智能指针 <code>Arc&lt;T&gt;</code></li><li>弱指针 <code>Weak&lt;T&gt;</code></li></ul></blockquote><ol start="9"><li>rust <strong>async/await</strong>作用理解： <strong>async</strong> 关键字将一个代码块转为为实现了<strong>future</strong>特征的状态机，使得在同步方法中调用阻塞函数（<strong>async</strong>转化的函数会阻塞整个线程），但是阻塞的<strong>future</strong>会让出线程控制权，允许其他<strong>future</strong>运行；而<strong>await</strong>关键字可以使<strong>async</strong>代码块中的其他<strong>async</strong>函数按顺序执行，当<strong>await</strong>发生阻塞时，不会阻塞当前线程，可以让其他任务执行。</li></ol><p>参考：<a href="https://zhuanlan.zhihu.com/p/144325440">https://zhuanlan.zhihu.com/p/144325440</a></p><p>异步测试代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此代码可以使task1 和 task2并发执行，根据 rust tokio调度器进行调度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span><span class="comment">// basic_scheduler threaded_scheduler </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// task1</span></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;########## &#123;&#125; current thread: &#123;:?&#125;&quot;</span>, <span class="number">1</span>, std::thread::current().id());</span><br><span class="line">        tokio::time::sleep(Duration::from_millis(<span class="number">3000</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;########## &#123;&#125; currnet end&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处休眠给 task1 进入 await状态时间, 交出它所在线程的执行权, </span></span><br><span class="line">    <span class="comment">// 使得task1和task2在同一个线程并发执行. 若不加，可能两个任务会</span></span><br><span class="line">    <span class="comment">// 分别在不同的线程中执行</span></span><br><span class="line">    tokio::time::sleep(Duration::from_millis(<span class="number">200</span>)).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// task2</span></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;########## &#123;&#125; current thread: &#123;:?&#125;&quot;</span>, <span class="number">2</span>, std::thread::current().id());</span><br><span class="line">        tokio::time::sleep(Duration::from_millis(<span class="number">1000</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;########## &#123;&#125; current end&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::time::sleep(Duration::from_millis(<span class="number">10000</span>)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="10"><li><p>Box 可以在堆上申请内存，当我们想解除 Box 获取内存时代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box_data_raw_ptr = <span class="built_in">Box</span>::into_raw(box_data);</span><br></pre></td></tr></table></figure><p>使用此方法后，Box 变量变回失效，不能再使用。</p><p>如果想把一块无人管理的内存转给 Box 管理，代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box_data_raw_ptr = <span class="built_in">Box</span>::into_raw(box_data);</span><br><span class="line"><span class="keyword">let</span> box_data_ptr = <span class="keyword">unsafe</span> &#123; <span class="built_in">Box</span>::from_raw(box_data_raw_ptr) &#125;;</span><br></pre></td></tr></table></figure></li><li><p>Rust <strong>mod关键字</strong>作用：</p><p>① 在当前目录下寻找 <strong>xxx.rs</strong> 文件。因为一个 rust 文件可以看成一个 module.</p><p>② 在当前目录下寻找 <strong>xxx/mod.rs</strong> 文件。此时 services 可以看做是一个命名空间.</p></li></ol><ol start="12"><li> Rust <strong>Cell</strong> 和 <strong>RefCell</strong> 的作用就是在提供结构体在不可变的时候，可以修改其中的某个成员.</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++的编程问题</title>
      <link href="/2021/08/19/C%E5%92%8CC++%E7%9A%84%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/19/C%E5%92%8CC++%E7%9A%84%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li>宏定义 ’**#<strong>‘ 和 ’</strong>##<strong>‘ 的使用说明: ‘</strong>#<strong>‘ 用于将代码转换成字符串; ‘</strong>##**’ 用于拼接代码; 使用范例:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PrintCode(x) #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_TYPE(x) int##x##_t</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">PrintCode</span>(<span class="keyword">int</span>) &lt;&lt; std::endl;<span class="comment">// 输出: int</span></span><br><span class="line"><span class="built_in">INT_TYPE</span>(<span class="number">64</span>) a;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; std::endl;<span class="comment">// 输出 8 因为 a是 int64_t</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>预处理指令</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FALSE<span class="comment">// 相当于 C语言中 if</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> TRUE<span class="comment">// 相当于 C语言中 else if</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span><span class="comment">// 相当于 C语言中 else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>C/C++ 不使用结构体字节对齐</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*减小内存占用的空间；结构体默认进行对齐，占用的空间比结构体内部成员变量字节加起来大，如果取消字节对齐，可以减小一部分空间。见下面具体例子。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">直接将结构体作为通信协议（在低带宽下通讯）；在不同的平台下，保证结构体内基本数据的长度相同，同时取消结构体的对齐，就可以将定义的数据格式结构体直接作为数据通信协议使用。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack (n)  <span class="comment">// 编译器将按照n个字节对齐；</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()   <span class="comment">// 恢复先前的pack设置,取消设置的字节对齐方式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack(pop)<span class="comment">// 恢复先前的pack设置,取消设置的字节对齐方式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack(1)  <span class="comment">// 按1字节进行对齐 即：不行进行对齐</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>GUN C 允许声明长度为0的数组，零长度数组可用作结构的最后一个元素，该结构实际上是可变长度对象的标头，内存分配如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="keyword">char</span> contents[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> *<span class="title">thisline</span> =</span> (struct line *)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct line) + this_length * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">thisline-&gt;length = this_length;</span><br></pre></td></tr></table></figure><ol start="5"><li>typedef 的前置声明：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> object defMyObject;</span><br><span class="line"><span class="keyword">typedef</span> myStruct defMyStruct;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span> <span class="title">object</span> <span class="title">defMyObject</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span> <span class="title">defMyStruct</span>;</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">object</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> object defMyObject;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> myStruct defMyStruct;</span><br></pre></td></tr></table></figure><ol start="6"><li>将文件内容全部读出（包括回车符）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">Read_Image</span><span class="params">(<span class="keyword">const</span> std::string &amp;_csImagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(_csImagePath.c_str(), std::ios::in)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> iBufSize = <span class="number">0</span>;</span><br><span class="line">    std::string sFileContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> letter;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::string sContent;</span><br><span class="line">        <span class="keyword">while</span> (file.<span class="built_in">get</span>(letter))</span><br><span class="line">        &#123;</span><br><span class="line">            iBufSize += <span class="number">1</span>;</span><br><span class="line">            sFileContent += letter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sFileContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>Windows平台<code>运行时库</code>各选项说明</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/MD使此应用程序使用特定于多线程和 DLL 的运行库版本。 定义 _MT 和 _DLL，并使编译器将库名 MSVCRT.lib 放入 .obj 文件中。</span><br><span class="line">用此选项编译的应用程序静态链接到 MSVCRT.lib。 此库提供使链接器能够解析外部引用的代码的层。 实际工作代码包含在 </span><br><span class="line">MSVCR versionnumber.DLL，该代码必须可运行时提供给与 MSVCRT.lib 链接的应用程序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/MDd定义 _DEBUG、_MT 和 _DLL，并使此应用程序使用特定于多线程和 DLL 的调试版本的运行库。 它还会让编译器将库 </span><br><span class="line">MSVCRTD.lib 放入 .obj 文件中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/MT使此应用程序使用运行库的多线程的静态版本。 定义 _MT，并使编译器将库名 LIBCMT.lib 放入 .obj 文件中，以便链接器 LIBCMT.lib 解析外部符号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/MTd定义 _DEBUG 和 _MT。 此选项还会让编译器将库名称 LIBCMTD.lib 放置到 .obj 文件中，以便链接器将使用 LIBCMTD.lib 来    解析外部符号。</span><br><span class="line"></span><br><span class="line">/LD创建一个 DLL。将 /DLL 选项传递给链接器。 链接器查找 DllMain 函数，但并不需要该函数。 如果没有编写 DllMain 函数，则链接  器将插入返回 TRUE 的 DllMain 函数。链接 DLL 启动代码。如果未在命令行上指定导出 (.exp) 文件，则创建导入库 (.lib)。 将导   入库链接到调用 DLL 的应用程序。将 /Fe (NAME EXE) 解释为命名 DLL，而不是.exe文件。 默认情况下，程序名称变</span><br><span class="line">basename.dll 而不是 basename.exe。</span><br><span class="line">表示 /MT， 除非显式指定 /MD。</span><br><span class="line"></span><br><span class="line">/LDd创建调试 DLL。 定义 _MT 和 _DEBUG。</span><br></pre></td></tr></table></figure><p>Windows平台的单线程和多线程运行库的区别在于，以前系统库有分只能用于单线程应用程序的库和可以跑在多线程模式下的库，所以在连接的时候需要指定单线程还是多线程。目前单线程选项已经弃用。</p><ol start="8"><li><strong>虽然C++的编译器对变量有默认的初始化（默认都是初始化0），但是在声明变量的时候一定要显式地赋值，这并不代表不赋值会造成编译或者运行错误，而是这是一个良好的习惯，帮助你注意到每一个变量，注意结构体中每一个成员变量！！！</strong></li></ol><ol start="9"><li><code>lambda</code>按值默认捕获 <code>[=]</code> 变量捕获只能针对于在创建<code>lambda</code>式的作用域内可见的非静态局部变量（包括形参）；静态变量对与lambda本身就是不用捕获就可以访问，所以如果只是想捕获其当前值，需要明确写出拷贝并且按值捕获这个拷贝，代码如下：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_state = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> iState = g_state;</span><br><span class="line">filters.<span class="built_in">emplace_back</span>([iState](<span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value % g_state;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14 起的写法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_state = <span class="number">1</span>;</span><br><span class="line">filters.<span class="built_in">emplace_back</span>([g_state = g_state](<span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value % g_state;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="10"><li><code>lambda</code> 使用初始化捕获将对象移入闭包</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 此处将局部变量使用移动构造，移入到匿名函数中，节省了拷贝开销, 实际上 C++14 中lambda可以全面替代std::bind</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; data = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>([](<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; data) &#123; ... &#125;, std::<span class="built_in">move</span>(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14起</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; data = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">auto</span> func = [data = std::<span class="built_in">move</span>(data)]() &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="11"><li><strong>SDL</strong>库中<strong>SDL_Event</strong>是一个很精妙的联合结构（<strong>union</strong>）, 众所周知，<strong>union</strong>（联合）同时只能初始化一个成员。但是在使用过程中，我们却可以同时访问它的 <strong>type</strong> 成员 和 其他一个事件结构体。代码如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SDL_Event user_event;</span><br><span class="line"></span><br><span class="line">user_event.type = SDL_USEREVENT;</span><br><span class="line">user_event.user.code = <span class="number">2</span>;</span><br><span class="line">user_event.user.data1 = <span class="literal">NULL</span>;</span><br><span class="line">user_event.user.data2 = <span class="literal">NULL</span>;</span><br><span class="line">SDL_PushEvent(&amp;user_event);</span><br></pre></td></tr></table></figure><p>​    可以这样做的原因是因为 <strong>SDL_Event</strong> 其他事件结构体都统一的将第一个成员声明为 <strong>Uint32 type</strong> ,  这样直接访问 <strong>SDL_Event.type</strong> 就可以访问到对应事件结构体的 <strong>type</strong> 成员。其他的事件结构体例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  \brief Keyboard button event structure (event.key.*)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDL_KeyboardEvent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Uint32 type;        <span class="comment">/**&lt; ::SDL_KEYDOWN or ::SDL_KEYUP */</span></span><br><span class="line">    Uint32 timestamp;   <span class="comment">/**&lt; In milliseconds, populated using SDL_GetTicks() */</span></span><br><span class="line">    Uint32 windowID;    <span class="comment">/**&lt; The window with keyboard focus, if any */</span></span><br><span class="line">    Uint8 state;        <span class="comment">/**&lt; ::SDL_PRESSED or ::SDL_RELEASED */</span></span><br><span class="line">    Uint8 repeat;       <span class="comment">/**&lt; Non-zero if this is a key repeat */</span></span><br><span class="line">    Uint8 padding2;</span><br><span class="line">    Uint8 padding3;</span><br><span class="line">    SDL_Keysym keysym;  <span class="comment">/**&lt; The key that was pressed or released */</span></span><br><span class="line">&#125; SDL_KeyboardEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  \brief Mouse motion event structure (event.motion.*)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDL_MouseMotionEvent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Uint32 type;        <span class="comment">/**&lt; ::SDL_MOUSEMOTION */</span></span><br><span class="line">    Uint32 timestamp;   <span class="comment">/**&lt; In milliseconds, populated using SDL_GetTicks() */</span></span><br><span class="line">    Uint32 windowID;    <span class="comment">/**&lt; The window with mouse focus, if any */</span></span><br><span class="line">    Uint32 which;       <span class="comment">/**&lt; The mouse instance id, or SDL_TOUCH_MOUSEID */</span></span><br><span class="line">    Uint32 state;       <span class="comment">/**&lt; The current button state */</span></span><br><span class="line">    Sint32 x;           <span class="comment">/**&lt; X coordinate, relative to window */</span></span><br><span class="line">    Sint32 y;           <span class="comment">/**&lt; Y coordinate, relative to window */</span></span><br><span class="line">    Sint32 xrel;        <span class="comment">/**&lt; The relative motion in the X direction */</span></span><br><span class="line">    Sint32 yrel;        <span class="comment">/**&lt; The relative motion in the Y direction */</span></span><br><span class="line">&#125; SDL_MouseMotionEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SDL_Event 结构如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">SDL_Event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Uint32 type;                            <span class="comment">/**&lt; Event type, shared with all events */</span></span><br><span class="line">    SDL_CommonEvent common;                 <span class="comment">/**&lt; Common event data */</span></span><br><span class="line">    SDL_DisplayEvent display;               <span class="comment">/**&lt; Display event data */</span></span><br><span class="line">...;</span><br><span class="line">    Uint8 padding[<span class="keyword">sizeof</span>(<span class="keyword">void</span> *) &lt;= <span class="number">8</span> ? <span class="number">56</span> : <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) == <span class="number">16</span> ? <span class="number">64</span> : <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)];</span><br><span class="line">&#125; SDL_Event;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GLib和GTK3</title>
      <link href="/2021/08/06/GLib%20and%20GTK3/"/>
      <url>/2021/08/06/GLib%20and%20GTK3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该篇为我学习GLib 和 GTK 的笔记，只是记录一些知识点和写法，若碰巧浏览此篇，尽量不要以此篇为准！</p></blockquote><h2 id="GLib相关介绍"><a href="#GLib相关介绍" class="headerlink" title="GLib相关介绍"></a>GLib相关介绍</h2><h3 id="GObject"><a href="#GObject" class="headerlink" title="GObject"></a>GObject</h3><hr><h4 id="GObject简单声明定义"><a href="#GObject简单声明定义" class="headerlink" title="GObject简单声明定义"></a>GObject简单声明定义</h4><p>GObject实现中， 类是两个结构体的组合，一个是<strong>实例结构体</strong>（保存所有对象私有数据），另一个是<strong>类结构体</strong>（保存所有对象共享的数据），其结构关系图如下：</p><p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021080601.png" alt="image-01"></p><h4 id="GObject-构造和析构大致过程"><a href="#GObject-构造和析构大致过程" class="headerlink" title="GObject 构造和析构大致过程"></a>GObject 构造和析构大致过程</h4><p>构造过程：</p><ul><li>注册 <strong>GObject</strong> 类型到类型系统，此操作是在执行 <strong>main</strong> 函数之前，<strong>glib</strong>初始化过程中完成的</li><li>分配内存给 <strong>GObjectClass</strong> 和 <strong>GObject  structure</strong></li><li>初始化 <strong>GObjectClass</strong> 结构体内存，这块内存是对象的类（类似C++类中的函数和静态变量）</li><li>初始化 <strong>GObject structure</strong> 内存， 这块内存属于实例</li></ul><p>注意：初始化流程是在第一次调用 <strong>g_object_new</strong> 函数时进行的。在第二次后续调用 <strong>g_object_new</strong>时，它只执行两步：</p><p>① 给 <strong>GObject structure</strong> 分配内存</p><p>② 初始化内存</p><p>析构过程：销毁 <strong>GObject</strong> 实例，内存释放，但是不会销毁 <strong>GObjectClass</strong>，即使所有<strong>GObject</strong>实例被回收，<strong>GObjectClass</strong>仍然存在</p><p>样例声明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dlist.h 实现一个列表类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glib-object.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PM_TYPE_DLIST (pm_dlist_get_type())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PMDListNode</span> <span class="title">PMDListNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">PMDListNode</span> &#123;</span></span><br><span class="line">        PMDListNode *prev;</span><br><span class="line">        PMDListNode *next;</span><br><span class="line">        <span class="keyword">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PMDList</span> <span class="title">PMDList</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">PMDList</span> &#123;</span></span><br><span class="line">        GObject parent_instance;</span><br><span class="line">        PMDListNode *head;</span><br><span class="line">        PMDListNode *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PMDListClass</span> <span class="title">PMDListClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PMDListClass</span> &#123;</span></span><br><span class="line">        GObjectClass parent_class;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">GType <span class="title">pm_dlist_get_type</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dlist.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dlist.h&quot;</span></span></span><br><span class="line"><span class="comment">// 对 pm_dlist_get_type 生成实现，返回类对象</span></span><br><span class="line"><span class="comment">// #arg_1: 类名 #arg_2: 成员函数命名前缀#arg_3: 父类型</span></span><br><span class="line">G_DEFINE_TYPE (PMDList, pm_dlist, G_TYPE_OBJECT);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pm_dlist_init</span> <span class="params">(PMDList *self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        g_printf (<span class="string">&quot;\t实例结构体初始化！\n&quot;</span>);</span><br><span class="line">        self-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">        self-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pm_dlist_class_init</span> <span class="params">(PMDListClass *klass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        g_printf (<span class="string">&quot;类结构体初始化!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GObject具有功能：</p><ul><li><p>基于引用计数的内存管理 —— 结合 <strong>g_object_ref</strong> 和 <strong>g_object_unref</strong> 两个函数对引用计数进行加减</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_object_ref(Obj) ((glib_typeof (Obj)) (g_object_ref) (Obj))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_object_unref</span> <span class="params">(gpointer object)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>对象的构造函数与析构函数</p></li><li><p>可设置对象属性的 set/get 函数</p></li><li><p>易于使用的信号机制</p></li></ul><p>继承GObject基类的实例化代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PMDList *dlist; <span class="comment">/* 类的实例化，产生对象 */</span></span><br><span class="line">dlist = g_object_new (PM_TYPE_DLIST, <span class="literal">NULL</span>); <span class="comment">/* 创建对象的一个实例 并将其引用计数 +1 */</span></span><br><span class="line">g_object_unref (dlist); <span class="comment">/* 将对象的实例引用计数 -1，并检测对象的实例的引用计数是否为 0，若为 0，那么便释放对象的实例的存储空间。 */</span></span><br><span class="line">dlist = g_object_new (PM_TYPE_DLIST, <span class="literal">NULL</span>); <span class="comment">/* 再创建对象的一个实例 */</span></span><br></pre></td></tr></table></figure><p>GObject子类化完整的过程：</p><blockquote><p>① 在 .h 文件中包含 glib-object.h；<br>② 在 .h 文件中构建实例结构体与类结构体，并分别将 GObject 类的实例结构体与类结构体置于成员之首；<br>③ 在 .h 文件中定义 P_TYPE_T 宏，并声明 p_t_get_type 函数；<br>④ 在 .c 文件中调用 G_DEFINE_TYPE 宏产生类型注册代码。</p></blockquote><p>声明的简单范例，参考地址： <a href="https://blog.csdn.net/knowledgebao/article/details/82418046">https://blog.csdn.net/knowledgebao/article/details/82418046</a></p><p><a href="https://github.com/ToshioCP/Gobject-tutorial/blob/main/gfm/sec2.md">https://github.com/ToshioCP/Gobject-tutorial/blob/main/gfm/sec2.md</a></p><h4 id="GObject-设置属性"><a href="#GObject-设置属性" class="headerlink" title="GObject 设置属性"></a>GObject 设置属性</h4><h4 id="GObject-的继承"><a href="#GObject-的继承" class="headerlink" title="GObject 的继承"></a>GObject 的继承</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kb-Son.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kb-Parent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KbSon</span> <span class="title">KbSon</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KbSon</span> &#123;</span></span><br><span class="line">        KbParent parent;<span class="comment">// 继承父实例属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KbSonClass</span> <span class="title">KbSonClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KParentClass</span> &#123;</span></span><br><span class="line">        KbParentClass parent_class;<span class="comment">// 继承父类属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kb-Son.c</span></span><br><span class="line">...</span><br><span class="line">G_DEFINE_TYPE(KbSon, kb_son, KB_TYPE_Parent);<span class="comment">// GType 设置成父类 其他代码一样</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>继承常用的宏（其中P表示项目名称     T表示类名称    PTPrivate表示私有数据结构体）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_TYPE_T (p_t_get_type())<span class="comment">// 仅在使用 g_object_new 进行对象实例化的时候使用一次，用于向 GObject 库的类型系统注册 PT 类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_T(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), P_TYPE_T, PT))<span class="comment">// 用于将 obj 对象的类型强制转换为 P_T 类的实例结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_IS_T(obj) G_TYPE_CHECK_INSTANCE_TYPE((obj), P_TYPE_T)) <span class="comment">// 用于判断 obj 对象的类型是否为 P_T 类的实例结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_T_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), P_TYPE_T, PTClass))<span class="comment">// 用于将 kclass 类结构体得类型强制转换为 P_T 类的类结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_IS_T_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), P_TYPE_T))<span class="comment">// 用于判断 klass 类结构体的类型是否为 P_T 类的类结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_T_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS((obj), P_TYPE_T, PTClass))<span class="comment">// 获取 obj 对象对应的类结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_T_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), P_TYPE_T, PTPrivate))<span class="comment">// 获取 obj 对象对应的私有数据</span></span></span><br></pre></td></tr></table></figure><p>接口常用的宏（其中 P 表示项目名称    T表示类名称    I是接口的缩写）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_TYPE_IT (p_t_get_type())<span class="comment">// 仅在接口实现时使用一次，用于向 GObject 库的类型系统注册 PIT 接口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_IT(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), P_TYPE_IT, P_IT))<span class="comment">// 用于将 obj 对象的类型强制转换为 P_IT 接口的实例结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_IS_IT(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), P_TYPE_IT))<span class="comment">// 用于判断 obj 对象是否为 P_IT接口的实例结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_IT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), P_TYPE_IT, P_IT))<span class="comment">// 获取 obj 对象对应的 P_IT 接口的类结构体类型</span></span></span><br></pre></td></tr></table></figure><h4 id="GObject-的信号使用"><a href="#GObject-的信号使用" class="headerlink" title="GObject 的信号使用"></a>GObject 的信号使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建信号</span></span><br><span class="line"><span class="function">guint <span class="title">g_signal_new</span> <span class="params">(<span class="keyword">const</span> gchar*signal_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                    GType   itype,</span></span></span><br><span class="line"><span class="params"><span class="function">                    GSignalFlagssignal_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                    guint           class_offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                    GSignalAccumulator accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">                    gpointer accu_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                    GSignalCMarshaller  c_marshaller,</span></span></span><br><span class="line"><span class="params"><span class="function">                    GType               return_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                    guint               n_params,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接信号和回调函数</span></span><br><span class="line"><span class="function">gulong <span class="title">g_signal_connect_data</span> <span class="params">(gpointerinstance, <span class="keyword">const</span> gchar*detailed_signal,</span></span></span><br><span class="line"><span class="params"><span class="function">                              GCallback  c_handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                              gpointer   data,</span></span></span><br><span class="line"><span class="params"><span class="function">                              GClosureNotify destroy_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                              GConnectFlags   connect_flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发射信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_signal_emit_by_name</span> <span class="params">(gpointerinstance, <span class="keyword">const</span> gchar*detailed_signal, ...)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="GTK"><a href="#GTK" class="headerlink" title="GTK"></a>GTK</h2><p><strong>GtkApplication</strong></p><p>用于处理GTK+初始化、应用程序唯一性、会话管理，通过导出操作和菜单提供一些基本的脚本能力和桌面shell集成，并管理一个顶级窗口列表，其生命周期自动绑定到应用程序的生命周期。</p><p><strong>GtkWindow</strong></p><p>一个 <strong>GtkWindow</strong> 是一个可以包含其他控件的顶级窗口，窗口通常在桌面系统下具有样式。并且允许用户放缩、移动或者关闭窗体等操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示窗体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gtk_window_present</span> <span class="params">(GtkWindow* window)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GLib GTK C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>meson</title>
      <link href="/2021/07/29/meson/"/>
      <url>/2021/07/29/meson/</url>
      
        <content type="html"><![CDATA[<h3 id="meson是什么"><a href="#meson是什么" class="headerlink" title="meson是什么"></a>meson是什么</h3><p><a href="https://mesonbuild.com/">Meson</a>是一个开源构建系统，旨在构建速度快和用户友好。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>对多个平台支持，例如：<strong>Linux</strong>、<strong>macOS</strong>、<strong>Windows</strong>、<strong>GCC</strong>、<strong>Clang</strong>、<strong>Visual Studio</strong>等等</li><li>支持语言包括<strong>C</strong>、<strong>C++<strong>、</strong>D</strong>、<strong>Fortran</strong>、<strong>Java</strong>、<strong>Rust</strong></li><li>在一个很好的可读性和用户友好的非图灵完备<strong>DSL</strong>(<strong>domain-specific language</strong> 特定领域的语言)中构建定义</li><li>可以在许多操作系统以及裸机交叉编译</li><li>针对极快的完整和增量构建进行了优化，而不牺牲正确性 —— （原文）<strong>optimized for extremely fast full and incremental builds without sacrificing correctness</strong></li><li>内置的多平台依赖项提供程序，可与发行版软件包协同工作</li><li>比较有意思…</li></ul><h3 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /your-project-path/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> meson builddir &amp;&amp; <span class="built_in">cd</span> builddir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> meson compile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> meson <span class="built_in">test</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 该命令是在工程目录下执行的，并非在工程目录下的编译目录执行的</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> DESTDIR=/your-project-path/root meson install -C ./builddir</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://mesonbuild.com/">https://mesonbuild.com/</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> meson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LLVM介绍及编译安装</title>
      <link href="/2021/07/18/LLVM%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/"/>
      <url>/2021/07/18/LLVM%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="LLVM介绍"><a href="#LLVM介绍" class="headerlink" title="LLVM介绍"></a>LLVM介绍</h2><p>LLVM的命名最早起源于底层语言虚拟机（Low Level Virtual Machine）的缩写 。它是一个用于建立编译器的基础框架，以C++编写。创建此工程的目的是对于任意汇编语言，利用该基础框架，构建一个包括编译时、链接时、执行时等的语言执行器。目前官方的LLVM只支持处理C/C++，Objective-C三种语言，当然的也有的一些非官方的扩展，使其支持ActionScript、Ada、D语言、Fortran、GLSL、HaskKell、Java bytecode、Objective-C、Python、Ruby、Rust、Scala以及C#。</p><p>传统的静态编译器分为三个阶段：前端、中端（优化）、后端，LLVM 也不例外，只是 LLVM 实现了一种<strong>与源编程语言和目标机器架构无关的通用中间表示——LLVM IR</strong>， 这样如果支持一种新的编程语言只需重新实现一个前端，支持一种新的目标架构只需重新实现一个后端，前端和后端的链接枢纽就是<strong>LLVM IR</strong></p><p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021071801.jpg" alt="image-01"></p><h2 id="LLVM项目编译部署"><a href="#LLVM项目编译部署" class="headerlink" title="LLVM项目编译部署"></a>LLVM项目编译部署</h2><p>一开始我只是想使用 <strong>Clang</strong> 编译器，但是又不想直接通过 <strong>apt-get</strong> （Ubuntu 20.04）的方式安装，所以尝试编译项目源码。</p><p>源码下载地址，这里我们直接选择 <a href="https://github.com/llvm/llvm-project">llvm-project</a>，因为这个项目不经包含llvm项目还有包含其他子项目（clang也在其中）。再编译之前要确保系统已经下载一下 <code>gcc  g++  make  cmake  python3</code></p><ul><li><p>首先 <code>cd  llvm-project</code> </p></li><li><p>在当前目录执行 <code>cmake -S llvm -B build -G &lt;generator&gt; [options]</code>，</p><p><code>generator</code> 选项如下：</p><ul><li><code>Ninja</code></li><li><code>Unix Makefiles</code></li><li><code>Visual Studio</code></li><li><code>Xcode</code></li></ul><p>这里我们选择 <code>&quot;Unix Makefiles&quot;</code></p><p>  比较常用的编译选项：</p><ul><li><code>-DLLVM_ENABLE_PROJECTS=&#39;...&#39;</code> 选择需要编译的子项目，例如：clang, clang-tools-extra, libcxx, libcxxabi, libunwind, lldb, compiler-rt, lld, polly, or cross-project-tests.</li><li><code>-DCMAKE_INSTALL_PREFIX=directory</code> 项目编译好后的下载目录，默认是 <code>/usr/local</code> </li><li><code>-DCMAKE_BUILD_TYPE=type</code> 编译类型，例如  Debug, Release, RelWithDebInfo, MinSizeRel。默认是Debug模式</li><li><code>-DLLVM_ENABLE_ASSERTIONS=On</code> 编译是否断言检测（Debug模式下默认开启，其他编译默认关闭）</li></ul></li></ul><p>​    我在编译的时候，命令执行如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -S llvm -B build -G &quot;Unix Makefiles&quot; -DLLVM_ENABLE_PROJECTS=&quot;clang;clang-tools-extra;libcxx;libcxxabi;libunwind;lldb;compiler-rt;lld;polly&quot; -DCMAKE_INSTALL_PREFIX=&quot;/usr/local/llvm-tool&quot; -DCMAKE_BUILD_TYPE=&quot;Release&quot;</span><br><span class="line"></span><br><span class="line">cmake --build build</span><br></pre></td></tr></table></figure><p>编译的时间非常漫长，我碰到过最长的编译时间了。看网上博客说有可能在编译的时候出现的内存不足的问题，如果你是用虚拟机进行编译可以扩大虚拟机内存。第一次编译的时候我遇到的一个 python 的模块缺失，下载补全模块就好。</p><p>编译完成后，到 <code>llvm-project</code> 的 <code>build</code>目录，执行 <code>make install</code> 命令后，llvm 的相关工具便会部署到之前cmake 指定的目录了！</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>① <a href="http://www.nagain.com/activity/article/4/">http://www.nagain.com/activity/article/4/</a></p><p>② <a href="https://zhuanlan.zhihu.com/p/102250532">https://zhuanlan.zhihu.com/p/102250532</a></p><p>③ <a href="https://github.com/llvm/llvm-project/blob/main/README.md">https://github.com/llvm/llvm-project/blob/main/README.md</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> LLVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebAssembly环境配置</title>
      <link href="/2021/07/14/WebAssembly%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/07/14/WebAssembly%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="WebAssembly-介绍"><a href="#WebAssembly-介绍" class="headerlink" title="WebAssembly 介绍"></a>WebAssembly 介绍</h2><p>WebAssembly（缩写为 Wasm）是一种用于基于堆栈的虚拟机的二进制指令格式。 Wasm 被设计为编程语言的可移植编译目标，支持在 Web 上部署客户端和服务器应用程序。简单来说就是可以将C/C++/Rust等语言编写的程序运行在浏览器上，这种技术有些类似于以前ActiveX等各种浏览器插件技术，所不同是 Wasm 被现在各种浏览器厂商所支持！</p><h2 id="Windows环境下，Qt配置WebAssembly"><a href="#Windows环境下，Qt配置WebAssembly" class="headerlink" title="Windows环境下，Qt配置WebAssembly"></a>Windows环境下，Qt配置WebAssembly</h2><p>目前 <strong>Qt5.15.2</strong> 版本支持 <strong>WebAssembly</strong> 编译！但在我配置的时候遇到了一些问题，步骤如下：</p><ul><li><p>首先在下载<strong>Qt</strong>时，选择版本 <strong>5.15.2</strong>，需要勾选 <strong>WebAssembly</strong>编译器，如下图：</p><p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021071401.png" alt="image-01"></p></li></ul><ul><li><p>当然因为缺少 [emscriptem][<a href="https://emscripten.org/]">https://emscripten.org/]</a>  导致 <strong>Qt</strong>的 <strong>WebAssembly</strong> 不可用。[emscriptem][<a href="https://emscripten.org/]">https://emscripten.org/]</a> 是一个WebAssembly编译器工具链，它是使用LLVM，注重速度、大小和web平台。通过<strong>git</strong> 或者直接访问<strong>github</strong>下载源码，在配置之前我们需要下载 <strong>python</strong> 来运行<strong>emscripten</strong>配置脚本。然后根据   [emscripten download][<a href="https://emscripten.org/docs/getting_started/downloads.html]">https://emscripten.org/docs/getting_started/downloads.html]</a> 下载说明进行配置。 注意 Qt 5.15.2的 <strong>WebAssembly</strong>编译器是需要下载 emsdk 1.39.8，</p><p>如下图：</p><p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021071402.png" alt="image-02"></p></li><li><p>配置好<strong>emscriptem</strong>后，打开<strong>QtCreator</strong>发现 <strong>Qt 5.15.2 WebAssembly</strong>依然是<strong>error</strong>状态如图:</p></li></ul><p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021071403.png" alt="image-03"></p><p>​    之前浏览别人博客，有人说要把<strong>emsdk</strong> 文件中 <strong>.emscripten</strong> 文件替换到用户目录下，以便<strong>QtCreator</strong> 可以找到<strong>emsdk</strong>的编译器。但 是我试过之后没有效果。后面询问过朋友之后，发现通过在设备中添加 <strong>emsdk</strong> 的路径可以解决这个问题（朋友万岁！！！），如图：</p><p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021071404.png" alt="image-04"></p><p>配置好设备之后重启一下<strong>QtCreator</strong>，应该就可以使用 <strong>Qt 5.15.2 WebAssembly</strong> 编译器了。</p><h2 id="跑在浏览器上的C-Qt-程序"><a href="#跑在浏览器上的C-Qt-程序" class="headerlink" title="跑在浏览器上的C++ Qt 程序"></a>跑在浏览器上的C++ Qt 程序</h2><p>使用 <strong>Qt WebAssembly</strong> 进行编译后默认使用IE浏览器呈现效果，但是IE并不支持 <strong>WebAssembly</strong> ，可以用<strong>Chrome</strong>、<strong>Edge</strong>等浏览器查看效果！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote><ol><li><a href="https://cloud.tencent.com/developer/news/690454">https://cloud.tencent.com/developer/news/690454</a></li><li><a href="https://blog.csdn.net/feiyangqingyun/article/details/112986837">https://blog.csdn.net/feiyangqingyun/article/details/112986837</a></li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Qt WebAssembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qml之PathView</title>
      <link href="/2021/06/27/qml%E4%B9%8BPathView/"/>
      <url>/2021/06/27/qml%E4%B9%8BPathView/</url>
      
        <content type="html"><![CDATA[<p>通过学习委托，涉及到 <strong>ListView</strong>、<strong>GridView</strong>、<strong>PathView</strong>等等；其中 <strong>PathView</strong> 的画风明显和 <strong>ListView</strong> 和 <strong>GridView</strong> 不一样，它的使用方式比较复杂，当然实现的效果真的很棒。那什么是 <strong>PathView</strong> 呢？</p><h2 id="PathView的定义"><a href="#PathView的定义" class="headerlink" title="PathView的定义"></a>PathView的定义</h2><p>首先先看 <strong>Qt</strong> 对<strong>PathView</strong>的描述如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 摘自 Qt Quick 5.12.2</span><br><span class="line">A PathView displays data from models created from built-in QML types like ListModel and XmlListModel, or custom model classes defined in C++ that inherit from QAbstractListModel.</span><br><span class="line">The view has a model, which defines the data to be displayed, and a delegate, which defines how the data should be displayed. The delegate is instantiated for each item on the path. The items may be flicked to move them along the path.</span><br></pre></td></tr></table></figure><p>这段描述比较轻描淡写，但它得作用类似 <strong>ListView</strong> 和 <strong>GridView</strong> 都是给 <strong>item</strong> 进行布局，但是不同于 <strong>ListView</strong> 列表形式的布局和 <strong>GirdView</strong> 栅格布局这种有规律描述布局，<strong>PathView</strong> 是根据用户提供路径， 将<strong>item</strong>按这个路径进行排布，比如：实现<strong>item</strong> 按照规则的曲线排布，这种排布方式是无规则的并不能通过一个统一的公式计算出<strong>item</strong>的分布。但<strong>PathView</strong> 可以实现类似的效果！通过自定义自己的路线组，让<strong>item</strong>按自定义的路径进行分布！</p><h2 id="PathView的使用"><a href="#PathView的使用" class="headerlink" title="PathView的使用"></a>PathView的使用</h2><p>代码如下：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">Component</span> &#123;</span><br><span class="line"><span class="attribute">id:</span><span class="string"> delegate_1</span></span><br><span class="line"><span class="title">Column</span> &#123;</span><br><span class="line"><span class="attribute">id:</span><span class="string"> wrapper</span></span><br><span class="line"><span class="attribute">opacity</span>: PathView.isCurrentItem ? <span class="number">1</span> : <span class="number">0.5</span></span><br><span class="line"><span class="title">Text</span> &#123;</span><br><span class="line"><span class="attribute">id:</span><span class="string"> nameText</span></span><br><span class="line"><span class="attribute">text</span>: name</span><br><span class="line"><span class="attribute">font.pointSize</span>: <span class="number">16</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">ListModel</span> &#123;</span><br><span class="line"><span class="attribute">id:</span><span class="string"> list_model</span></span><br><span class="line"><span class="title">ListElement</span> &#123;</span><br><span class="line"><span class="attribute">name</span>: <span class="string">&quot;Bill Jones&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title">ListElement</span> &#123;</span><br><span class="line"><span class="attribute">name</span>: <span class="string">&quot;Jane Doe&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title">ListElement</span> &#123;</span><br><span class="line"><span class="attribute">name</span>: <span class="string">&quot;John Smith&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title">ListElement</span> &#123;</span><br><span class="line"><span class="attribute">name</span>: <span class="string">&quot;John Smith&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">PathView</span> &#123;</span><br><span class="line"><span class="attribute">anchors.fill</span>: <span class="built_in">parent</span></span><br><span class="line"><span class="attribute">model</span>: list_model</span><br><span class="line"><span class="attribute">delegate</span>: delegate_1</span><br><span class="line"><span class="comment">// PathView 通过给予 path 属性自定义路径, 让 item 按 Path&#123;&#125; 定义路径分布</span></span><br><span class="line"><span class="attribute">path</span>: <span class="title">Path</span>&#123;</span><br><span class="line"><span class="attribute">startX</span>: <span class="number">200</span>; <span class="attribute">startY</span>: <span class="number">100</span><span class="comment">// 路径得起点 (200, 100)</span></span><br><span class="line"><span class="title">PathLine</span> &#123; <span class="attribute">relativeX</span>: <span class="number">200</span>; <span class="attribute">relativeY</span>: <span class="number">200</span> &#125;<span class="comment">// 从起点到 (200 + relativeX, 100, relativeY) 的直线</span></span><br><span class="line"><span class="title">PathPercent</span> &#123; <span class="attribute">value</span>: <span class="number">0.5</span> &#125;<span class="comment">// 设置前一个路径上可以分布多少比例的item 数量</span></span><br><span class="line"><span class="title">PathLine</span> &#123; <span class="attribute">relativeX</span>: <span class="number">200</span>; <span class="attribute">relativeY</span>: <span class="number">-200</span> &#125; <span class="comment">// 以上一条路径的终点为起点开始的一条路径</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>PathView</strong> 通过给予 <strong>path</strong> 属性自定义路径, 让 <strong>item</strong> 按 <strong>Path{}</strong> 定义路径分布。Path{} 提供了多个描述路径对象，如下图：</p><p><img src="https://raw.githubusercontent.com/mingxingren/Notes/master/resource/photo/image-2021062701.png" alt="image-01"></p><h4 id="PathLine使用"><a href="#PathLine使用" class="headerlink" title="PathLine使用"></a>PathLine使用</h4><p><strong>PathLine</strong> 顾名思义描述一条直线路径，其起点是上一条路径终点。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>开发中遇到的有关Qt的问题</title>
      <link href="/2021/06/12/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E6%9C%89%E5%85%B3Qt%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2021/06/12/%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E6%9C%89%E5%85%B3Qt%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li><p>向下面的代码对某 a 列设置伸展属性后， 再设置 b 列的列宽为 0 时导致无法隐藏这一列，b 列会显示一个固定宽度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ui-&gt;tablewidget-&gt;<span class="built_in">horizontalHeader</span>()-&gt;<span class="built_in">setSectionResizeModel</span>(<span class="number">1</span>, QHeaderView::Stretch);</span><br></pre></td></tr></table></figure></li><li><p><strong>QStyle</strong> 类中 <strong>drawPrimitive</strong> 方法解读</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief drawPrimitive 绘制原生控件</span></span><br><span class="line"><span class="comment">  * @param element 要绘制原生控件类型， 例如: 按钮 文本 复选框等</span></span><br><span class="line"><span class="comment">  * @param option 渲染空间的参数, 例如: element 是 PE_PanelButtonCommand —— 按钮, 那么在渲染的时候需要知道要渲染位置，尺寸，颜色等等, 这些参数都由 option 指定</span></span><br><span class="line"><span class="comment">  * @param painter 实际执行渲染的设备</span></span><br><span class="line"><span class="comment">  * @param widget The widget argument is optional and may contain a widget that may aid in drawing the primitive element.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QStyle::drawPrimitive</span><span class="params">(QStyle::PrimitiveElement element, <span class="keyword">const</span> QStyleOption *option, QPainter *painter, <span class="keyword">const</span> QWidget *widget = <span class="literal">nullptr</span>)</span> <span class="keyword">const</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>QLineEdit</strong> 的 <strong>placeholderText()</strong> 是指当 QLineEdit 内容为空时, 会显示编辑框的提示内容 , 用户输入那内容后就消</p></li><li><p>当 <strong>QTableWidget</strong> 某单元格内容很长显示不下时, <strong>QTableWidgetItem</strong> 可以设置 <strong>ToolTip()</strong> , 这样当光标移入该单元格时会弹出提示文本</p></li><li><p>获取 <strong>A</strong> 控件的 <strong>QStyle</strong> 对象, 调用该对象的<strong>drawControl</strong> 绘制带有 <strong>Qss</strong> 样式的控件, 需要对 <strong>A</strong> 控件先设置 <strong>Qss</strong> 属性否则调用 <strong>drawControl</strong> 无法的让 <strong>Qss</strong> 样式生效.</p></li><li><p><strong>QGraphicsView</strong> 相当于一个窗户， <strong>QGraphicsScene</strong> 相当于窗外的景色。如果不做其他设置<strong>QGraphicsScene</strong> 的中心(注意此处中心不是 <strong>QGraphicsScene</strong> 的原点)处于<strong>QGraphicsView</strong> 区域的中心， <strong>x</strong>轴向右， <strong>y</strong>轴向下。而这个原点可以的在 <strong>QGraphicsView</strong> 的坐标系上被记录。<strong>QGraphicsView::setSceneRect</strong> 可以调整 <strong>QGraphicsScene</strong> 的坐标范围，例如<strong>QGraphicsView::setSceneRect(-10, 10,  200,  200)</strong> 表示 Scene 的坐标范围为**(-10, -10, 200, 200)<strong>。但是</strong>QGraphicsView** 中心最初还是和 <strong>QGraphicsScene</strong> 的中心重合</p></li></ol><ol start="7"><li><p><strong>QMetaObject::invokeMethod</strong> 非常好用, 它可以省去 <strong>connect</strong> 这个动作，却可以像 <strong>connect</strong> 一样的效果调用的目标对象的槽函数或者是被 <strong>Q_INVOKABLE</strong> 标记的函数; 但请注意, 用 <strong>QMetaObject::invokeMethod</strong> 去调用槽函数时, 槽函数并不能通过 <strong>QObject::sender()</strong> 获得到调用对象，返回的地址是 <strong>0x0</strong>。</p></li><li><p><strong>QBoxLayout</strong> 对某个<strong>QWidget</strong>对象或者 <strong>QLayout</strong> 设置 <strong>stretch</strong> (权值) 为0, 其效果是在主动拉伸的时候, 这一列不做垂直方向或者水平方向的长度变化。当对某个 QWidget 设置了(<strong>sizePolicy</strong>)垂直策略或者水平策略为 <strong>Fixed</strong>, 则该水平方向上不会拉伸(该优先级比父类布局的权值优先级更高)</p></li><li><p>在使用布局时候，子控件谨慎使用 <strong>FixedSize</strong> 等类似方法， 例如: 当子控件放进 <strong>H</strong>水平布局，<strong>H</strong>布局放进一个<strong>V</strong>垂直布局并且给这个<strong>H</strong>布局的权值(<strong>stretch</strong>)设为<strong>0</strong>，想让 <strong>V</strong> 布局在垂直方向拉伸时，<strong>H</strong>布局的高度不变。但当对子控件设置 <strong>FixedSize</strong> 时， 并且 <strong>FixedSize</strong> 设置的高度超过了 <strong>V</strong> 布局分配给H布局的高度时, 此时 <strong>V</strong> 布局对<strong>H</strong>布局设置的权值被打破，并且<strong>H</strong>布局会跟着<strong>V</strong>布局一起做拉伸。</p></li><li><p><strong>QCompleter</strong>  配置 <strong>QLineEdit</strong>  , <strong>QCombobox</strong> 实现动态输入匹配功能, 其匹配模式看以参看枚举变量 <strong>Qt::MatchFlag</strong> 。QCompleter 默认维护一个 QListView 控件用于显示补全的信息，其源码为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment">Returns the popup used to display completions.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">\sa setPopup()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">QAbstractItemView *<span class="title">QCompleter::popup</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Q_D</span>(<span class="keyword">const</span> QCompleter);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> QT_CONFIG(listview)</span></span><br><span class="line"><span class="keyword">if</span> (!d-&gt;popup &amp;&amp; <span class="built_in">completionMode</span>() != QCompleter::InlineCompletion) &#123;</span><br><span class="line">QListView *listView = <span class="keyword">new</span> QListView;</span><br><span class="line">listView-&gt;<span class="built_in">setEditTriggers</span>(QAbstractItemView::NoEditTriggers);</span><br><span class="line">listView-&gt;<span class="built_in">setHorizontalScrollBarPolicy</span>(Qt::ScrollBarAlwaysOff);</span><br><span class="line">listView-&gt;<span class="built_in">setSelectionBehavior</span>(QAbstractItemView::SelectRows);</span><br><span class="line">listView-&gt;<span class="built_in">setSelectionMode</span>(QAbstractItemView::SingleSelection);</span><br><span class="line">listView-&gt;<span class="built_in">setModelColumn</span>(d-&gt;column);</span><br><span class="line">QCompleter *that = <span class="keyword">const_cast</span>&lt;QCompleter*&gt;(<span class="keyword">this</span>);</span><br><span class="line">that-&gt;<span class="built_in">setPopup</span>(listView);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// QT_CONFIG(listview)</span></span></span><br><span class="line"><span class="keyword">return</span> d-&gt;popup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在使用的时候， 可以使用 <strong>Qss</strong> 对 <strong>QCompleter</strong>  持有的 <strong>QListView</strong> 样式生效。因为 <strong>QListView</strong> 在 默认声明的时候并没有将父类指针指向 <strong>QLineEdit</strong> 或 其他对象(实际给<strong>QLineEdit</strong> 赋予一个父指针会使补全功能失效 )。可以给 <strong>QLineEdit</strong> 统一设置同一个 <strong>objectname</strong>， 然后使用全局<strong>Qss</strong> 设置，让所有的补全编辑框保持统一风格</p></li></ol><ol start="11"><li><p><strong>QLineEdit</strong> 配合 <strong>QAction</strong> 可以实现编辑框的内置图标，  <strong>QAction</strong> 还可以配合 <strong>QMenu</strong>、<strong>QToolButton</strong>等控件</p></li><li><p><strong>QOpenGLWdget</strong> 和 <strong>QGLWidget</strong> 的透明度问题相关讨论地址: <a href="https://blog.csdn.net/qq21497936/article/details/94635225">https://blog.csdn.net/qq21497936/article/details/94635225</a></p></li><li><p>通过重写 <strong>QGraphicsItem</strong> 的 <strong>type()</strong> 方法， 自定义 <strong>item</strong> 类型值, 枚举值从 <strong>QGraphicsItem::UserType</strong> 的基础上递增。配合 <strong>qgraphicsitem_cast</strong> 进行基类<strong>item</strong>向子类自定义的<strong>item</strong>转换。使用例子如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QGraphicsItem *&gt; items = scene-&gt;<span class="built_in">items</span>();</span><br><span class="line">foreach (QGraphicsItem *item, items) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item-&gt;<span class="built_in">type</span>() == QGraphicsRectItem::Type) &#123;  <span class="comment">// 矩形</span></span><br><span class="line">        QGraphicsRectItem *rect = qgraphicsitem_cast&lt;QGraphicsRectItem*&gt;(item);</span><br><span class="line">        <span class="comment">// 访问 QGraphicsRectItem 的成员</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item-&gt;<span class="built_in">type</span>() == QGraphicsLineItem::Type) &#123;  <span class="comment">// 直线</span></span><br><span class="line">        QGraphicsLineItem *line = qgraphicsitem_cast&lt;QGraphicsLineItem*&gt;(item);</span><br><span class="line">        <span class="comment">// 访问 QGraphicsLineItem 的成员</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item-&gt;<span class="built_in">type</span>() == QGraphicsProxyWidget::Type) &#123;  <span class="comment">// 代理 Widget</span></span><br><span class="line">        QGraphicsProxyWidget *proxyWidget = qgraphicsitem_cast&lt;QGraphicsProxyWidget*&gt;(item);</span><br><span class="line">        QLabel *label = qobject_cast&lt;QLabel *&gt;(proxyWidget-&gt;<span class="built_in">widget</span>());</span><br><span class="line">        <span class="comment">// 访问 QLabel 的成员</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item-&gt;<span class="built_in">type</span>() == CustomItem::Type) &#123;  <span class="comment">// 自定义 Item</span></span><br><span class="line">        CustomItem *customItem = qgraphicsitem_cast&lt;CustomItem*&gt;(item);</span><br><span class="line">        <span class="comment">// 访问 CustomItem 的成员</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他类型 item</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>QHeaderView</strong> 可以通过 <strong>setSectionResizeMode</strong> 设置表头调节大小的属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">QHeaderView</span>:</span>:ResizeMode</span><br><span class="line">&#123;</span><br><span class="line">    QHeaderView::Interactive,  <span class="comment">///&lt; 可以通过鼠标等对表头单元进行拖拽来调整宽度</span></span><br><span class="line">    QHeaderView::Fixed, <span class="comment">///&lt; 只能通过程序设置调整表头单元宽度</span></span><br><span class="line">    QHeaderView::Stretch,<span class="comment">///&lt; 表头单元格尺寸根据剩余下的宽度做尺寸调整 其他修改方式无效</span></span><br><span class="line">    QHeaderView::ResizeToContents,<span class="comment">///&lt; 根据表头里面的文本内容来调整表头宽度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>宏定义 <strong>’#‘</strong> 和 <strong>’##‘</strong> 的使用说明: <strong>‘#’</strong> 用于将代码转换成字符串; <strong>‘##’</strong> 用于拼接代码; 使用范例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PrintCode(x) #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_TYPE(x) int##x##_t</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">PrintCode</span>(<span class="keyword">int</span>) &lt;&lt; std::endl;<span class="comment">// 输出: int</span></span><br><span class="line"><span class="built_in">INT_TYPE</span>(<span class="number">64</span>) a;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; std::endl;<span class="comment">// 输出 8 因为 a是 int64_t</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Qss 选择想要选择多个同级的控件, 用逗号分割，例如:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPushButton<span class="selector-id">#button_1</span>, QPushButton<span class="selector-id">#button_2</span> &#123; <span class="attribute">color</span>:red; &#125;</span><br></pre></td></tr></table></figure></li><li><p>STL 容器在调用resize做内存扩充时, 会默认初始化 节点<T>对象，STL 源码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type __new_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (__new_size &gt; <span class="built_in">size</span>())</span><br><span class="line">  _M_default_append(__new_size - <span class="built_in">size</span>());</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (__new_size &lt; <span class="built_in">size</span>())</span><br><span class="line">  _M_erase_at_end(<span class="keyword">this</span>-&gt;_M_impl._M_start + __new_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">void</span> vector&lt;_Tp, _Alloc&gt;::_M_default_append(size_type __n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size_type</span>(<span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">- <span class="keyword">this</span>-&gt;_M_impl._M_finish) &gt;= __n)</span><br><span class="line">&#123;</span><br><span class="line">  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);</span><br><span class="line">  <span class="keyword">this</span>-&gt;_M_impl._M_finish =</span><br><span class="line">std::__uninitialized_default_n_a(<span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line"> __n, _M_get_Tp_allocator());</span><br><span class="line">  _GLIBCXX_ASAN_ANNOTATE_GREW(__n);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> size_type __len =</span><br><span class="line">_M_check_len(__n, <span class="string">&quot;vector::_M_default_append&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> size_type __old_size = <span class="keyword">this</span>-&gt;<span class="built_in">size</span>();</span><br><span class="line">  pointer __new_start(<span class="keyword">this</span>-&gt;_M_allocate(__len));</span><br><span class="line">  pointer __new_finish(__new_start);</span><br><span class="line">  __try</span><br><span class="line">&#123;</span><br><span class="line">  __new_finish</span><br><span class="line">= std::__uninitialized_move_if_noexcept_a</span><br><span class="line">(<span class="keyword">this</span>-&gt;_M_impl._M_start, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line"> __new_start, _M_get_Tp_allocator());</span><br><span class="line">  __new_finish =</span><br><span class="line">std::__uninitialized_default_n_a(__new_finish, __n,</span><br><span class="line"> _M_get_Tp_allocator());</span><br><span class="line">&#125;</span><br><span class="line">  __catch(...)</span><br><span class="line">&#123;</span><br><span class="line">  std::_Destroy(__new_start, __new_finish,</span><br><span class="line">_M_get_Tp_allocator());</span><br><span class="line">  _M_deallocate(__new_start, __len);</span><br><span class="line">  __throw_exception_again;</span><br><span class="line">&#125;</span><br><span class="line">  _GLIBCXX_ASAN_ANNOTATE_REINIT;</span><br><span class="line">  std::_Destroy(<span class="keyword">this</span>-&gt;_M_impl._M_start, <span class="keyword">this</span>-&gt;_M_impl._M_finish,</span><br><span class="line">_M_get_Tp_allocator());</span><br><span class="line">  _M_deallocate(<span class="keyword">this</span>-&gt;_M_impl._M_start,</span><br><span class="line"><span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage</span><br><span class="line">- <span class="keyword">this</span>-&gt;_M_impl._M_start);</span><br><span class="line">  <span class="keyword">this</span>-&gt;_M_impl._M_start = __new_start;</span><br><span class="line">  <span class="keyword">this</span>-&gt;_M_impl._M_finish = __new_finish;</span><br><span class="line">  <span class="keyword">this</span>-&gt;_M_impl._M_end_of_storage = __new_start + __len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>QPlainTextEdit</strong> 在 <strong>minimumHeight</strong> 设置为 <strong>0</strong> 后， 此时将 <strong>QPlainTextEdit</strong> 放入到布局中，运行后用鼠标整个窗体进行缩小, <strong>QPlainTextEdit</strong> 在缩小到某种程度便会停止从而撑起整个布局， 并不会缩小到 <strong>0px</strong></p></li></ol><ol start="19"><li><p>在想声明成员变量都是同类型的结构体时，例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">T_A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">3</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以用结合数组和枚举的形式，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">eIndex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">EINDEX_a = <span class="number">0</span>,</span><br><span class="line">    EINDEX_b,</span><br><span class="line">    EINDEX_c,</span><br><span class="line">    ...</span><br><span class="line">    EINDEX_size</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arriA[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ...&#125;;</span><br><span class="line"><span class="comment">// 取值</span></span><br><span class="line">arriA[EINDEX_a] = <span class="number">10</span>;</span><br><span class="line">arriA[EINDEX_b] = <span class="number">10</span>;</span><br><span class="line">arriA[EINDEX_c] = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样的好处是当成员变量非常多的时候，可以使用 for 循环进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; EINDEX_size; i++)</span><br><span class="line">&#123;</span><br><span class="line">    arriA[i] += <span class="number">10</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以前在使用 <strong>Qt</strong> 槽函数的时候经常遇到 <strong>signal</strong> 名称重复的情况，例如以前 <strong>QNetworkReply</strong> 在比较低的版本，其信号 <strong>error</strong> 和 其公有方法<strong>error</strong> 冲突。导致并不能直接使用 <strong>functor</strong>式的连接，然后可以使用 <strong>static_cast</strong> 进行一些的转换，如下：</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(networkReply, <span class="keyword">static_cast</span>&lt;<span class="built_in"><span class="keyword">void</span></span>(QNetworkReply::*)(QNetworkReply::NetworkError)&gt;(&amp;QNetworkReply::error),</span><br><span class="line">    [=](QNetworkReply::NetworkError code)&#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure><p>偶然发现 <strong>QGlobal.h</strong> 提供 <strong>QOverload</strong> 来简化上面例子中的写法，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(networkReply, QOverload&lt;QNetworkReply::NetworkError&gt;::<span class="built_in">of</span>(&amp;QNetworkReply::error),</span><br><span class="line">    [=](QNetworkReply::NetworkError code)&#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure><p>相比于使用 <strong>static_cast</strong> 要理解晦涩难懂函数指针,  <strong>QOverload</strong> 则是隐藏了 函数指针的转换，对新手来说更容易理解，以下是 <strong>QOverload</strong> 的源码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QOverload</span> :</span> QConstOverload&lt;Args...&gt;, QNonConstOverload&lt;Args...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> QConstOverload&lt;Args...&gt;::of;</span><br><span class="line"><span class="keyword">using</span> QConstOverload&lt;Args...&gt;::<span class="built_in"><span class="keyword">operator</span></span>();</span><br><span class="line"><span class="keyword">using</span> QNonConstOverload&lt;Args...&gt;::of;</span><br><span class="line"><span class="keyword">using</span> QNonConstOverload&lt;Args...&gt;::<span class="built_in"><span class="keyword">operator</span></span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="function">Q_DECL_CONSTEXPR <span class="keyword">auto</span> <span class="title">operator</span><span class="params">()</span><span class="params">(R (*ptr)(Args...))</span> <span class="keyword">const</span> Q_DECL_NOTHROW -&gt; <span class="title">decltype</span><span class="params">(ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Q_DECL_CONSTEXPR <span class="keyword">auto</span> <span class="title">of</span><span class="params">(R (*ptr)(Args...))</span> Q_DECL_NOTHROW -&gt; <span class="title">decltype</span><span class="params">(ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="21"><li><strong>QML</strong> 中动态创建的自定义组件方法之一, 代码如下：</li></ol><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先将 自定义组件类型 转换成 组件对象，然后通过这个组件对象实例化出自定义组件对象</span></span><br><span class="line">Qt.createComponent(<span class="string">&quot;TestWindow.qml&quot;</span>).createObject();</span><br></pre></td></tr></table></figure><ol start="22"><li><strong>C++</strong> <strong>window</strong>版本 <strong>MinGW</strong>编译器 <strong>C++14</strong>， 在类声明的头文件， 在类中声明 <strong>std::array</strong> 并初始化，代码如下:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTestClass</span>&#123;</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 2&gt; arrTest = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样声明并初始化会报错，错误为: array must be initialized with a brace-enclosed initializer</span></span><br><span class="line"><span class="comment">// 在类外声明 或者 在cpp文件中声明是正常的，原因不明，看了 C++ 的官方文档，发现以前是双括号的写法，代码如下(不会报错):</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CTestClass</span>&#123;</span></span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 2&gt; arrTest = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="23"><li><strong>MySql</strong>中的反引号是为了区分<strong>MySql</strong>的保留字和普通字符而引入的符号。所谓的保留字就是 <strong>select database  insert</strong> 等等数据库的<strong>Sql</strong>指令，如果需要拿这些指令作为表名和字段名时，需要加反引号 <strong>``</strong> 来避免编译器把这部分认为是保留字而产生错误。注: 纯数字作为字段名、表名等也需要加反引号!</li></ol><ol start="24"><li><strong>C++</strong> 为保证每个实例在内存中是唯一的，编译器会给一个空类隐含的加一个字节, 保证实例化出的类是唯一的</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span>&#123;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a)=&quot;</span>&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(a)&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: sizeof(a)=1</span></span><br></pre></td></tr></table></figure><ol start="25"><li><strong>Qt</strong> 的信号和槽机制本质上是观察者模式应用，通过 <strong>moc</strong> (<strong>Meta-Object Compiler</strong> 元对象编译) 对使用 <strong>Q_OBJECT</strong> 宏生成 <strong>moc</strong> 文件里面包含 <strong>类的描述</strong>和<strong>存储信号函数列表</strong>，并且给信号函数生成定义，查看其内部就是去调用绑定这个信号的槽函数！ 在接收对象用connect 建立连接时，实际上</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QScopedPointer&lt;QObjectPrivate::Connection&gt; <span class="title">c</span><span class="params">(<span class="keyword">new</span> QObjectPrivate::Connection)</span></span>;</span><br><span class="line">c-&gt;sender = s;   <span class="comment">//发送者</span></span><br><span class="line">c-&gt;signal_index = signal_index;<span class="comment">//信号索引</span></span><br><span class="line">c-&gt;receiver = r;<span class="comment">//接收者</span></span><br><span class="line">c-&gt;method_relative = method_index;<span class="comment">//槽函数索引</span></span><br><span class="line">c-&gt;method_offset = method_offset;<span class="comment">//槽函数偏移 主要是区别于多个信号</span></span><br><span class="line">c-&gt;connectionType = type;<span class="comment">//连接类型</span></span><br><span class="line">c-&gt;isSlotObject = <span class="literal">false</span>;<span class="comment">//是否是槽对象 默认是true</span></span><br><span class="line">c-&gt;argumentTypes.<span class="built_in">store</span>(types);<span class="comment">//参数类型</span></span><br><span class="line">c-&gt;nextConnectionList = <span class="number">0</span>;<span class="comment">//指向下个连接对象</span></span><br><span class="line">c-&gt;callFunction = callFunction;<span class="comment">//静态回调函数，也就是qt_static_metacall</span></span><br><span class="line"></span><br><span class="line">QObjectPrivate::<span class="built_in">get</span>(s)-&gt;<span class="built_in">addConnection</span>(signal_index, c.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure><p>​    到此 <strong>Qt</strong> 的信号和槽大致的结构便是如此，<strong>UML</strong> 如下：</p><p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021071201.png" alt="image-01"></p><ol start="26"><li><p>QCombobox 让下拉列表某项不能被选择但依然可以显示，因为 QCombobox 实际上默认拥有一个<strong>model(QStandardItemModel)</strong> 和一个 <strong>QListView</strong> 用来显示下拉列表。所以知道对 <strong>model</strong> 的某一项重新设置一下 <strong>flag</strong> 就可以了。代码 如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QStandardItemModel* pModel = <span class="keyword">dynamic_cast</span>&lt;QStandardItemModel*&gt;(ui-&gt;comboxBox-&gt;<span class="built_in">model</span>());</span><br><span class="line"><span class="keyword">if</span> (pModel)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 设置第一行 为禁用和不可选中状态</span></span><br><span class="line">    pModel-&gt;<span class="built_in">item</span>(<span class="number">0</span>)-&gt;<span class="built_in">setFlags</span>(pModel-&gt;<span class="built_in">item</span>(<span class="number">0</span>)-&gt;<span class="built_in">flags</span>() &amp; ~(Qt::ItemIsSelectable|Qt::ItemIsEnabled));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>QML 学习之路</title>
      <link href="/2021/06/12/qml%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"/>
      <url>/2021/06/12/qml%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p>工作了三年，一直用<strong>QGui</strong> 开发比较简单的程序，之所以开始接触<strong>QML</strong>是因为现在客户端已经逐渐转入<strong>JavaScript</strong> 那套开发模式，这绝非危言耸听，并且推出 <strong>webassembly</strong> 后，我认为客户端和前端会逐渐走向<strong>UI</strong>逻辑由<strong>JavaScript</strong>编写，高性能的运算和操作系统设备会给 <strong>C/C++/Rust</strong> 编写的 <strong>webassembly</strong>  模块执行，这可能客户端真正意义上的强后端分离。虽然很不想承认，自己过去三年所学的技术正在犹如日出日落般推出主流的客户端开发，可能仅仅只能维持老的项目和嵌入式方向， 但客户端和前端能做的事情变得越来越多，深度也在不加深，以前人们一直以为后端比前端更有技术含量，从现在来看，前端程序员逐渐百花齐放起来，他们实现得很多效果，我自认拍马也赶不上。 为了以后能有碗饭吃，我决定给自己挖一口井，学习<strong>QML</strong> 并从<strong>QML</strong>逐渐过度到前端学习上。好了，现在开始吧！</p><h2 id="什么是-QML"><a href="#什么是-QML" class="headerlink" title="什么是 QML"></a>什么是 <strong>QML</strong></h2><p>可能你对 <strong>HTML</strong> 比较熟悉，其实 <strong>QML</strong> 要做的事情和HTML 有些类似 —— 描述用户界面。<strong>QML</strong> 用于描述用户界面元素的形状和行为。用户界面能够使用 <strong>JavaScript</strong> 来提供修饰，或者增加更加复杂的逻辑。其结构层次：子元素从父元素上继承坐标系统，它的 <strong>x，y</strong> 坐标总是对应于它的父元素坐标系统。</p><p>首先使用一个简单的 <strong>QML</strong> 例子：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.12</span></span><br><span class="line"><span class="keyword">import</span> QtQuick.Window <span class="number">2.12</span></span><br><span class="line"></span><br><span class="line"><span class="title">Window</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">640</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">480</span></span><br><span class="line">    <span class="attribute">visible</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attribute">title</span>: qsTr(<span class="string">&quot;测试窗口&quot;</span>)</span><br><span class="line">    <span class="title">Text</span> &#123;</span><br><span class="line">        <span class="attribute">id:</span><span class="string"> helloWord</span></span><br><span class="line">        <span class="attribute">text</span>: qsTr(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">        <span class="attribute">anchors.centerIn</span>: <span class="built_in">parent</span></span><br><span class="line">        <span class="attribute">font.bold</span>: <span class="literal">true</span>;</span><br><span class="line">        <span class="attribute">font.pointSize</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>import</strong> 声明导入一个指定模块，<strong>JavaScript</strong>资源和组件目录，写法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;ModuleIdentifier&gt; &lt;Version.Number&gt; [<span class="keyword">as</span> &lt;Qualifier&gt;]</span><br></pre></td></tr></table></figure></li><li><p>每个 <strong>.qml</strong>  文件有且只有一个根元素！整个结构为属性结构</p></li><li><p>任何在 <strong>QML</strong> 文档中的元素可以通过 属性<strong>id</strong> 进行访问，在同一个 .qml 文件里，<strong>id</strong> 是唯一的 （注意: <em><strong>一个元素id应该只在当前文档中被引用。QML提供了动态作用域的机制，后加载的文档会覆盖之前加载文档的元素id号，这样就可以引用已加载并且没有被覆盖的元素id，这有点类似创建全局变量。但不幸的是这样的代码阅读性很差。目前这个还没有办法解决这个问题，所以你使用这个机制的时候最好仔细一些甚至不要使用这种机制。如果你想向文档外提供元素的调用，你可以在根元素上使用属性导出的方式来提供</strong></em>。）</p></li></ul><h2 id="元素属性-（Properties）"><a href="#元素属性-（Properties）" class="headerlink" title="元素属性 （Properties）"></a>元素属性 （Properties）</h2><p>属性是可以赋予静态值或绑定到动态表达式的对象的属性。属性的值可以由其他对象读取。通常，它也可以由另一个对象修改，除非特定的 <strong>QML</strong> 类型明确禁止对特定属性执行此操作。</p><table><thead><tr><th align="center">属性值的类型</th><th align="center"><strong>解释</strong></th></tr></thead><tbody><tr><td align="center">静态值</td><td align="center">不依赖其他属性的值的常量</td></tr><tr><td align="center">绑定表达式</td><td align="center">描述属性与其他属性关系的JavaScript表达式。此表达式中的变量称为属性的依赖项。<br/>QML引擎强制执行属性及其依赖项之间的关系。当任何依赖项的值发生更改时，QML引擎会自动重新计算绑定表达式，并将新结果赋给该属性。</td></tr></tbody></table><p><strong>QML</strong> 提供基础组件例如：<strong>Item</strong>、<strong>Text</strong>等都有自己特有的 <strong>Property</strong>， 并且我们可以添加组件的额外属性，其写法如下：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property</span><span class="string"> type name </span>: value</span><br></pre></td></tr></table></figure><p>其中 <strong>type</strong> 指 <strong>value</strong> 的类型，<strong>qml</strong> 支持的值类型如下：</p><table><thead><tr><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">true/false</td></tr><tr><td align="center">double</td><td align="center">双精度浮点型</td></tr><tr><td align="center">enumeration</td><td align="center">命名枚举值</td></tr><tr><td align="center">int</td><td align="center">整形</td></tr><tr><td align="center">list</td><td align="center">QML 对象列表</td></tr><tr><td align="center">real</td><td align="center">等同于 double</td></tr><tr><td align="center">string</td><td align="center">字符串</td></tr><tr><td align="center">url</td><td align="center">资源定位器</td></tr><tr><td align="center">var</td><td align="center">通用类型，根据值进行推到</td></tr><tr><td align="center">date</td><td align="center">日期</td></tr><tr><td align="center">point</td><td align="center">(x, y)</td></tr><tr><td align="center">rect</td><td align="center">(x, y, width, height)</td></tr><tr><td align="center">size</td><td align="center">(width, height)</td></tr></tbody></table><p>除了添加组件自定义属性， 还可以使用 <strong>alias</strong> 关键字用于转发一个属性或者转发一个组件对象的属性(例如： 组件想暴露子对象的属性)，一个属性别名不需要类型，它会根据引用的属性进行推导。语法如下：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">property</span><span class="string"> alias proprerty_name </span>: another.proprety_name </span><br><span class="line"><span class="keyword">property</span><span class="string"> alias new_name </span>: old_name </span><br></pre></td></tr></table></figure><h2 id="基本元素-（Basic-Element）"><a href="#基本元素-（Basic-Element）" class="headerlink" title="基本元素 （Basic Element）"></a>基本元素 （Basic Element）</h2><p>元素可以被分为可视化元素和非可视元素。一个可视化元素（例如矩形框Rectangle）有着几何形状并且可以在屏幕上显示。一个非可视化元素（例如计时器Timer）提供了常用的功能，通常用于操作可视化元素。</p><p>Item 是所有可视化元素的基础对象，所有其他的可视化元素都继承自Item。 它自身不会有任何绘制操作，但是定义了所有可视化元素共有的属性：</p><table><thead><tr><th>Group(分组)</th><th>Properties（属性）</th></tr></thead><tbody><tr><td>Geometry (几何属性)</td><td>x， y （坐标）定义了元素左上角的位置，width，height(长和宽) 定义元素的显示范围，z(堆叠次序)定义元素之间的重叠顺序</td></tr><tr><td>Layout handling（布局操作）</td><td>anchors（锚定），包括左（left），右（right），上（top），下（bottom），水平与垂直居中（vertical center，horizontal center），与margins（间距）一起定义了元素与其它元素之间的位置关系。</td></tr><tr><td>Key handling（按键操作）</td><td>附加属性 key (按键) 和 keyNavigation（按键定位）属性来控制按键操作，处理输入焦点（focus）可用操作</td></tr><tr><td>Transformation（转换）</td><td>缩放（scale）和rotate（旋转）转换，通用的x,y,z属性列表转换（transform），旋转基点设置（transformOrigin）。</td></tr><tr><td>Visual （可视化）</td><td>不透明度（opacity）控制透明度，visible（是否可见）控制元素是否显示，clip（裁剪）用来限制元素边界的绘制，smooth（平滑）用来提高渲染质量。</td></tr><tr><td>State definition（状态定义）</td><td>states（状态列表属性）提供了元素当前所支持的状态列表，当前属性的改变也可以使用transitions（转变）属性列表来定义状态转变动画。</td></tr></tbody></table><h2 id="定位元素-（Positioning-Element）"><a href="#定位元素-（Positioning-Element）" class="headerlink" title="定位元素 （Positioning Element）"></a>定位元素 （Positioning Element）</h2><p>分为：<strong>Column</strong>、<strong>Row</strong>、<strong>Grid（栅格布局）</strong>、<strong>Flow（流式）</strong></p><h2 id="布局元素-（Layout-Items）"><a href="#布局元素-（Layout-Items）" class="headerlink" title="布局元素 （Layout Items）"></a>布局元素 （Layout Items）</h2><p>一般 <strong>QML</strong> 使用 <strong>anchors</strong>（锚）对元素进行布局。其优先级比几何变化（例如：<strong>x</strong>、<strong>y</strong>、<strong>width</strong>、<strong>height</strong>）高， 这可以理解成 <strong>QGui</strong></p><p>中布局优先级比 <strong>width</strong> 和 <strong>height</strong> 高。</p><h2 id="声明信号和触发槽函数"><a href="#声明信号和触发槽函数" class="headerlink" title="声明信号和触发槽函数"></a>声明信号和触发槽函数</h2><p><strong>QML</strong> 和 <strong>QWidget</strong> 一样也有信号和槽函数，其声明方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal &lt;signalName&gt;[([&lt;type&gt; &lt;parameter name&gt;[, ...]])]</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// TestDialog.qml</span><br><span class="line"></span><br><span class="line">import QtQuick 2.0</span><br><span class="line">import QtQuick.Controls 2.12</span><br><span class="line"></span><br><span class="line">Dialog &#123;</span><br><span class="line">    id: root</span><br><span class="line">    title: &quot;TestDialog&quot;</span><br><span class="line">    standardButtons:  Dialog.Ok | Dialog.Cancel</span><br><span class="line">    </span><br><span class="line">    signal signal_result(string result)</span><br><span class="line"></span><br><span class="line">    onAccepted: &#123;</span><br><span class="line">        root.signal_result(&quot;accept&quot;);</span><br><span class="line">        root.close();</span><br><span class="line">    &#125;</span><br><span class="line">    onRejected: &#123;</span><br><span class="line">        root.signal_result(&quot;rejecct&quot;);</span><br><span class="line">        root.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>槽函数和 <strong>QWidget</strong>  上的 <strong>ui</strong> 文件上控件声明槽函数类似，属性名直接使用 <strong>on +  signalName</strong> 形式，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TestDialog &#123;</span><br><span class="line">...</span><br><span class="line">onSignal_result:&#123;</span><br><span class="line">console.log(result)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件附加属性-和-附加信号"><a href="#组件附加属性-和-附加信号" class="headerlink" title="组件附加属性 和 附加信号"></a>组件附加属性 和 附加信号</h2><p>概念：<strong><em>Attached properties</em> and <em>attached signal handlers</em> are mechanisms that enable objects to be annotated with extra properties or signal handlers that are otherwise unavailable to the object. In particular, they allow objects to access properties or signals that are specifically relevant to the individual object.</strong></p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;AttachingType&gt;.&lt;propertyName&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">AttachingType</span>&gt;</span>.on<span class="tag">&lt;<span class="name">SignalName</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>自我理解：不是很明白这个概念，使用起来像委托生成的每个组件<strong>Item</strong>都拥有一个 <strong>View</strong> 对象，用来访问 <strong>View</strong> 管理该<strong>Item</strong>一些属性。例如：<strong>GridView</strong> 里面的 <strong>item</strong>  并没有表示 自己是选中的<strong>item</strong> 这种属性，并且如果真这样实现是不合理，因为当要改变选中行时，你还需要去寻找之前被选中的<strong>item</strong>(挨个遍历)，所以 <strong>isCurrentItem</strong> 这个属性给 <strong>GridView</strong> 会好一点。</p><p>附加属性使用样例：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="title">ListView</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">240</span>; <span class="attribute">height</span>: <span class="number">320</span></span><br><span class="line">    <span class="attribute">model</span>: <span class="number">3</span></span><br><span class="line">    <span class="attribute">delegate</span>: <span class="title">Rectangle</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100</span>; <span class="attribute">height</span>: <span class="number">30</span></span><br><span class="line">        <span class="attribute">color</span>: ListView.isCurrentItem ? <span class="string">&quot;red&quot;</span> : <span class="string">&quot;yellow&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制组件-Canvas"><a href="#绘制组件-Canvas" class="headerlink" title="绘制组件 Canvas"></a>绘制组件 Canvas</h2><h2 id="粒子系统"><a href="#粒子系统" class="headerlink" title="粒子系统"></a>粒子系统</h2><h2 id="Loader-动态加载-、Binding-属性绑定-、-Connections-信号动态创建"><a href="#Loader-动态加载-、Binding-属性绑定-、-Connections-信号动态创建" class="headerlink" title="Loader(动态加载)、Binding(属性绑定)、 Connections(信号动态创建)"></a>Loader(动态加载)、Binding(属性绑定)、 Connections(信号动态创建)</h2><h2 id="QML-结合-C-使用"><a href="#QML-结合-C-使用" class="headerlink" title="QML 结合 C++ 使用"></a>QML 结合 C++ 使用</h2><p>参考链接：<a href="https://www.cnblogs.com/linuxAndMcu/p/11961090.html">https://www.cnblogs.com/linuxAndMcu/p/11961090.html</a></p><h2 id="QQuick-提供的原生控件"><a href="#QQuick-提供的原生控件" class="headerlink" title="QQuick 提供的原生控件"></a>QQuick 提供的原生控件</h2><table><thead><tr><th><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-abstractbutton.html">AbstractButton</a></th><th>提供抽象按钮，抽象出来各种按钮通用功能</th></tr></thead><tbody><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-action.html">Action</a></td><td>抽象用户界面操作</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-actiongroup.html">ActionGroup</a></td><td>将 Action 组合</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-applicationwindow.html">ApplicationWindow</a></td><td>支持页眉和页脚的顶级窗口</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-busyindicator.html">BusyIndicator</a></td><td>指示后台活动，例如在加载内容</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-button.html">Button</a></td><td>通过单击触发命令或响应的按钮</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-buttongroup.html">ButtonGroup</a></td><td>互斥的按钮组</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-checkbox.html">CheckBox</a></td><td>勾选框</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-checkdelegate.html">CheckDelegate</a></td><td>勾选框的委托</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-combobox.html">ComboBox</a></td><td>下拉框</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-container.html">Container</a></td><td>Abstract base type providing functionality common to containers</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-control.html">Control</a></td><td>对所有控件进行抽象</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-delaybutton.html">DelayButton</a></td><td>长按按钮</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-dial.html">Dial</a></td><td>Circular dial that is rotated to set a value</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-dialog.html">Dialog</a></td><td>弹出带标准按钮和标题的窗体，用于和用户临时交互</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-dialogbuttonbox.html">DialogButtonBox</a></td><td>类似按钮布局，用户只需要在里面添加按钮，它会根据不同平台，对按钮进行先后顺序摆放</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-drawer.html">Drawer</a></td><td>通过手势上下左右滑，滑出抽屉控件</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-frame.html">Frame</a></td><td>给一组控件增加可视边框</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-groupbox.html">GroupBox</a></td><td>给一组控件增加可视边框和标题，继承于 GroupBox</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-horizontalheaderview.html">HorizontalHeaderView</a></td><td>水平方向表头</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-itemdelegate.html">ItemDelegate</a></td><td>基础的Item委托</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-label.html">Label</a></td><td>具有继承字体 带样式的文本标签</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-menu.html">Menu</a></td><td>弹出菜单</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-menubar.html">MenuBar</a></td><td>主窗体的菜单栏</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-menubaritem.html">MenuBarItem</a></td><td>Presents a drop-down menu within a MenuBar</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-menuitem.html">MenuItem</a></td><td>Presents an item within a Menu</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-menuseparator.html">MenuSeparator</a></td><td>Separates a group of items in a menu from adjacent items</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-overlay.html">Overlay</a></td><td>A window overlay for popups</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-page.html">Page</a></td><td>带有页头和页脚的控件</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-pageindicator.html">PageIndicator</a></td><td>类似于轮播图效果中指示控件</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-pane.html">Pane</a></td><td>Provides a background matching with the application style and theme</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-popup.html">Popup</a></td><td>弹出用户控件的基础类型</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-progressbar.html">ProgressBar</a></td><td>进度条</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-radiobutton.html">RadioButton</a></td><td>单选按钮</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-radiodelegate.html">RadioDelegate</a></td><td>单选按钮委托</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-rangeslider.html">RangeSlider</a></td><td>Used to select a range of values by sliding two handles along a track</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-roundbutton.html">RoundButton</a></td><td>A push-button control with rounded corners that can be clicked by the user</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-scrollbar.html">ScrollBar</a></td><td>Vertical or horizontal interactive scroll bar</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-scrollindicator.html">ScrollIndicator</a></td><td>Vertical or horizontal non-interactive scroll indicator</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-scrollview.html">ScrollView</a></td><td>Scrollable view</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-slider.html">Slider</a></td><td>Used to select a value by sliding a handle along a track</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-spinbox.html">SpinBox</a></td><td>Allows the user to select from a set of preset values</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-splithandle.html">SplitHandle</a></td><td>Provides attached properties for SplitView handles</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-splitview.html">SplitView</a></td><td>Lays out items with a draggable splitter between each item</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-stackview.html">StackView</a></td><td>Provides a stack-based navigation model</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-swipedelegate.html">SwipeDelegate</a></td><td>Swipable item delegate</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-swipeview.html">SwipeView</a></td><td>Enables the user to navigate pages by swiping sideways</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-switch.html">Switch</a></td><td>开关按钮</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-switchdelegate.html">SwitchDelegate</a></td><td>开关按钮的委托</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-tabbar.html">TabBar</a></td><td>Allows the user to switch between different views or subtasks</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-tabbutton.html">TabButton</a></td><td>页签按钮</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-textarea.html">TextArea</a></td><td>输入文本区域（多行）</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-textfield.html">TextField</a></td><td>输入文本区域（单行）</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-toolbar.html">ToolBar</a></td><td>ToolButton和相关控件的容器对象</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-toolbutton.html">ToolButton</a></td><td>对话框工具按钮</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-toolseparator.html">ToolSeparator</a></td><td>用于工具栏的分割符</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-tooltip.html">ToolTip</a></td><td>提示</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-tumbler.html">Tumbler</a></td><td>可以选择的旋转滚轮</td></tr><tr><td><a href="https://doc.qt.io/qt-5/qml-qtquick-controls2-verticalheaderview.html">VerticalHeaderView</a></td><td>垂直方向表头</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Qt QML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/06/12/hello-world/"/>
      <url>/2021/06/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
