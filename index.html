<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/mingxingren/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/mingxingren/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/mingxingren/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/mingxingren/images/logo.svg" color="#222">

<link rel="stylesheet" href="/mingxingren/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;github.com&quot;,&quot;root&quot;:&quot;&#x2F;mingxingren&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;mingxingren&#x2F;images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;mingxingren&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:-1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script><script src="/mingxingren/js/config.js"></script>
<meta name="description" content="挖一口自己的井">
<meta property="og:type" content="website">
<meta property="og:title" content="mingxingren的博客">
<meta property="og:url" content="https://github.com/mingxingren/index.html">
<meta property="og:site_name" content="mingxingren的博客">
<meta property="og:description" content="挖一口自己的井">
<meta property="og:locale">
<meta property="article:author" content="mingxingren">
<meta property="article:tag" content="多少句都形容不了我">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://github.com/mingxingren/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:true,&quot;isPost&quot;:false,&quot;lang&quot;:&quot;zh-Hans&quot;,&quot;comments&quot;:&quot;&quot;,&quot;permalink&quot;:&quot;&quot;,&quot;path&quot;:&quot;index.html&quot;,&quot;title&quot;:&quot;&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>mingxingren的博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/mingxingren/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/mingxingren/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">mingxingren的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="mingxingren"
      src="/mingxingren/images/avatar01.png">
  <p class="site-author-name" itemprop="name">mingxingren</p>
  <div class="site-description" itemprop="description">挖一口自己的井</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/mingxingren/archives">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/mingxingren/2022/07/28/C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mingxingren/images/avatar01.png">
      <meta itemprop="name" content="mingxingren">
      <meta itemprop="description" content="挖一口自己的井">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingxingren的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mingxingren/2022/07/28/C#%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">C#知识整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-07-28 10:23:00 / 修改时间：10:23:46" itemprop="dateCreated datePublished" datetime="2022-07-28T10:23:00+08:00">2022-07-28</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>C#  函数传递地址的方式有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static void AddSum(ref int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">   i += j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">AddSum(ref a, b);</span><br></pre></td></tr></table></figure></li>
<li><p>C# 中的数据类型分 <code>值类型</code> 和 <code>引用类型</code>.</p>
<p>① 值类型: 直接存储数据的值, 保存在内存中. 一些预定义简单类型,  例如: <code>int</code>, <code>float</code>, <code>bool</code>, <code>char</code> 都是值类型, 另外 <code>enum</code>, <code>struct</code> 也是值类型</p>
<p>② 引用类型: 存储对值的引用, 实际上存储的就是一个内存的地址. <code>string</code>, <code>数组</code>,<code>class</code>, <code>interface</code>, <code>委托</code>和 <code>封装</code> 都是引用类型，其中 string 是比较特殊的引用类型</p>
</li>
<li><p>C# 泛型编程使用 <code>where</code> 约束</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    约束                说明</span><br><span class="line">    T: struct          类型参数必须是值类型. 可以指定除 Nullable 以外的任何值类型</span><br><span class="line">    </span><br><span class="line">    T: class           类型参数必须是引用类型，包括任何类、接口、委托或者数组类型</span><br><span class="line">    </span><br><span class="line">    T：new()            类型参数必须具有无参数的公共构造函数. 当与其他约束一起使用时, new()</span><br><span class="line">                        约束必须最后指定</span><br><span class="line">    </span><br><span class="line">    T:&lt;基类名&gt;           类型参数必须是指定的基类或派生自指定的基类</span><br><span class="line">    </span><br><span class="line">    T:&lt;接口名称&gt;         类型参数必须是指定的接口或者实现指定的接口. 可以指定多个接口约束. 约束</span><br><span class="line">                        接口也可以是泛型的</span><br><span class="line">    </span><br><span class="line">    T: U                为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数.</span><br><span class="line">                        这称为裸类型约束</span><br></pre></td></tr></table></figure></li>
<li><p>C# params 关键字</p>
<p>在 C# 中, 使用 <code>params</code> 关键字可以给一个方法 (method) 传递数量可变的参数 ( paramter ), 类似于<code>python</code> 中的 <code>*arg</code></p>
<p>注:</p>
<p>① <code>params</code>后面的参数类型必须是一个数组</p>
<p>② <code>params</code>后面不允许再有其他参数</p>
<p>③ 一个方法的申明中只能又一个 <code>params</code> 关键字</p>
<p>传递方式:</p>
<p>① 用逗号分隔的一串参数</p>
<p>② 一个一维数组</p>
<p>③ 空参数, <code>length</code> 为 0</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/mingxingren/2022/07/13/%E7%9C%9F%E5%BF%83%E4%B8%BA%E4%BD%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mingxingren/images/avatar01.png">
      <meta itemprop="name" content="mingxingren">
      <meta itemprop="description" content="挖一口自己的井">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingxingren的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mingxingren/2022/07/13/%E7%9C%9F%E5%BF%83%E4%B8%BA%E4%BD%A0/" class="post-title-link" itemprop="url">真心为你</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-07-13 22:17:00 / 修改时间：22:19:44" itemprop="dateCreated datePublished" datetime="2022-07-13T22:17:00+08:00">2022-07-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="真心为你"><a href="#真心为你" class="headerlink" title="真心为你"></a>真心为你</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/mingxingren/2022/06/21/%E5%85%89%E7%85%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mingxingren/images/avatar01.png">
      <meta itemprop="name" content="mingxingren">
      <meta itemprop="description" content="挖一口自己的井">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingxingren的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mingxingren/2022/06/21/%E5%85%89%E7%85%A7/" class="post-title-link" itemprop="url">光照</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-06-21 16:04:00 / 修改时间：16:05:12" itemprop="dateCreated datePublished" datetime="2022-06-21T16:04:00+08:00">2022-06-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><h2 id="简单的颜色叠加"><a href="#简单的颜色叠加" class="headerlink" title="简单的颜色叠加"></a>简单的颜色叠加</h2><p>两个颜色向量相乘等于最终的反射颜色</p>
<h2 id="基础光照"><a href="#基础光照" class="headerlink" title="基础光照"></a>基础光照</h2><p>① 环境光照(Ambient Lighting): 即使在黑暗的情况下，世界上通常也仍然有一些光亮(月亮、远处的光)，所以物体几乎永远不会是完全黑暗的. 为了模拟这个，我们会使用一个环境光照常量，它永远给物体一些颜色.</p>
<p>实现:  用光的颜色乘以一个很小常量环境因子，再乘以物体的颜色，然后将最终结果作为片段的颜色.</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">float</span> ambientStrength = <span class="number">0.1</span>;</span><br><span class="line">    <span class="type">vec3</span> ambient = ambientStrength * lightColor;</span><br><span class="line">    </span><br><span class="line">    <span class="type">vec3</span> result = ambient * objectColor;</span><br><span class="line">    FragColor = <span class="type">vec4</span>(result, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>② 漫反射光照(Diffuse Lighting): 模拟光源对物体的方向性影响(Directional Impact). 它是冯氏光照模型中视觉上最显著的分量. 物体的某一个部分越是正对着光源，它就会越亮.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 算出 光源点指向着色点 的单位向量</span><br><span class="line">2. 单位向量与平面法线向量点乘 算出光线向量是否在法线方向有大于0的分量</span><br><span class="line">3. 与 光的颜色 相乘算出 光通过反射损失后的系数 a</span><br><span class="line">4. a 与 环境光系数相加得出 b</span><br><span class="line">5. b 与 物体表面颜色相乘得出最终颜色</span><br></pre></td></tr></table></figure>



<p>注: 每当我们应用一个不等比缩放时（等比缩放不会破坏法线，因为法线的方向没被改变，仅仅改变法线的长度，很容易通过标准化来修复）,  法向量就不会再垂直于对应表面了，这样光照就会破坏. 可以使用 <code>法线矩阵</code> 来移除对法向量错误缩放的影响</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Normal = <span class="type">mat3</span>(<span class="built_in">transpose</span>(<span class="built_in">inverse</span>(model))) * aNormal;</span><br></pre></td></tr></table></figure>

<p><code>矩阵求逆是一项对于着色器开销很大的运算，因为它必须再场景中的每一个顶点上进行，所以应该尽可能地避免在着色器中进行求逆运算. 所以我们需要在 CPU 上计算出法线矩阵，然后再通过 uniform 把它传递给着色器在GPU资源中做计算</code></p>
<p>③ 镜面光照(Specular Lighting): 模拟有光泽物体上面出现的亮点. 镜面光照的颜色相比于物体的颜色会更倾向于光的颜色.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 获取观察者坐标</span><br><span class="line">2. 获取着色点指向观察点的向量 a </span><br><span class="line">3. 通过入射光和法线算出反射光线 b</span><br><span class="line">4. a 和 b 点乘</span><br><span class="line">5. 根据 反光度(Shininess) 算出高光系数</span><br><span class="line">glsl code eg:</span><br><span class="line">	vec3 result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line">	FragColor = vec4(result, 1.0);</span><br></pre></td></tr></table></figure>



<h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><p>现实世界里，每个物体会对光产生不同的反应. 比如，钢制物体看起来通常会比陶土花瓶更闪闪发光，一个木头箱子也不会与一个钢制箱子反射同样程度的光. 有些物体反射光的时候不会有太多的散射(Scatter), 因而产生较小的高光点，而有些物体会散射很多，产生一个有着更大半径的高光点. 如果我们想要在 <code>OpenGL</code> 中模拟多种类型的物体，需要对每种表面定义不同的<code>材质</code>属性</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">struct Meterial &#123;</span><br><span class="line">	<span class="type">vec3</span> ambient;	<span class="comment">// 环境光</span></span><br><span class="line">    <span class="type">vec3</span> diffuse;	<span class="comment">// 漫反射</span></span><br><span class="line">    <span class="type">vec3</span> specular;	<span class="comment">// 镜面光照</span></span><br><span class="line">    <span class="type">float</span> shininess;	<span class="comment">// 高光系数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uniform</span> Material meterial;</span><br></pre></td></tr></table></figure>

<p>在片段着色器中，我们创建一个结构体(Struct)来存储物体的材质属性，我们也可以把它们存储为独立的 <code>uniform</code> 值，但是作为</p>
<p>一个结构体来存储会更有条理一点. 我们首先定义结构体的布局(Layout), 然后简单地以刚创建的结构体作为类型声明一个 <code>uniform</code> 变量.</p>
<p>如你所见，我们为冯氏光照模型的每个分量都定义一个颜色向量. <code>ambient</code> 材质向量定义了在环境光照下这个表面反射的是什么颜色，</p>
<p>通常与表面的颜色相同. <code>diffuse</code> 材质向量定义了在漫反射光照下表面的颜色. 漫反射颜色(和环境光照一样) 也被设置为我们期望的物体颜色. <code>specular</code>材质向量设置的是表面上镜面高光的颜色(或者甚至可能反应一个特定表面的颜色). 最后，<code>shininess</code> 影响镜面高光的散射/半径.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/mingxingren/2022/03/27/%E5%9F%BA%E4%BA%8EFFmpeg%E5%92%8CDX11%E7%9A%84%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91%E2%80%94%E2%80%94%E7%BF%BB%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mingxingren/images/avatar01.png">
      <meta itemprop="name" content="mingxingren">
      <meta itemprop="description" content="挖一口自己的井">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingxingren的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mingxingren/2022/03/27/%E5%9F%BA%E4%BA%8EFFmpeg%E5%92%8CDX11%E7%9A%84%E6%B5%81%E5%AA%92%E4%BD%93%E8%A7%86%E9%A2%91%E2%80%94%E2%80%94%E7%BF%BB%E8%AF%91/" class="post-title-link" itemprop="url">基于FFmpeg和DX11的流媒体视频——翻译</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-27 20:21:36 / 修改时间：20:28:27" itemprop="dateCreated datePublished" datetime="2022-03-27T20:21:36+08:00">2022-03-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="基于FFMPEG-和-DirectX11的流媒体视频"><a href="#基于FFMPEG-和-DirectX11的流媒体视频" class="headerlink" title="基于FFMPEG 和 DirectX11的流媒体视频"></a>基于FFMPEG 和 DirectX11的流媒体视频</h1><p>事情起因：因为工作需求，我需要使用ffmpeg进行硬解实时视频并显示到屏幕, 但是性能一直不太理想。偶然发现一篇英文博客与我的需求类似，所以我决定翻译这边英文博客，这是原文地址：<a target="_blank" rel="noopener" href="https://medium.com/swlh/streaming-video-with-ffmpeg-and-directx-11-7395fcb372c4">https://medium.com/swlh/streaming-video-with-ffmpeg-and-directx-11-7395fcb372c4</a></p>
<p>在几个月之前，我被分配开发一个低延迟的视频播放器。在之前，我只接触过FFmpeg没接触过DirectX11。但是我认为它应该不难。FFmpeg是非常受欢迎的，DirectX11也出现了很长一段时间了，并且我应该不会用到3D图形或者更复杂的东西。</p>
<p>所以，应该会有一些能借鉴的解码和渲染视频例子，是吧？</p>
<p>但很不幸，没有…， 因此才写这篇文章。</p>
<p>所以下一个对FFmpeg和DirectX11不熟悉的人不必为了显示视频而伤脑筋。</p>
<p>首先，我们需要搞清楚一些重要的事情</p>
<p>① 样例代码需要足够简单。我省略返回码检测的，错误处理等，我的观点是代码例子就只是例子（我会提供更全面得例子，但是你知道，知识产权等等）</p>
<p>② 我不会介绍硬件加速视频解码/渲染原理，因为它有点超出了本文的范围。此外，还有很多其他资源比我能更好地解释它</p>
<p>③ ffmpeg 支持相当多地协议和编码格式。RTSP 和 UDP 的例子都有用它，h264和h265编码同样用到ffmpeg，我相信很多人参考它。</p>
<p>④ 我使用CMake创建此工程，使它不依赖Visual Studio’s 编译平台（因为我们同样需要支持不需要DirectX的渲染）。这让事情变得更加有难度，这就是我为什么提到它</p>
<h2 id="第一步：设置源流和视频解码器"><a href="#第一步：设置源流和视频解码器" class="headerlink" title="第一步：设置源流和视频解码器"></a>第一步：设置源流和视频解码器</h2><p>这是ffmpeg这块的，只是设置格式上下文，解码上下文，和所有ffmpeg需要的结构体。对于此处，我参考了<a target="_blank" rel="noopener" href="https://ffmpeg.org/doxygen/3.4/hw__decode_8c_source.html">这个例子</a>和<a href="https://github.com/moonlight-stream/moonlight-qt/blob/master/app/streaming/video/ffmpeg.cpp">MoonLight</a>的源码。</p>
<p>注意你需要以某种方式向 AVCodecContext 提供硬件设备类型。我选择与ffmpeg相同的方式执行此操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize stream</span></span><br><span class="line"><span class="keyword">const</span> std::string hw_device_name = <span class="string">&quot;d3d11va&quot;</span>;</span><br><span class="line">AVHWDeviceType device_type = <span class="built_in">av_hwdevice_find_type_by_name</span>(hw_device_name.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="comment">// set up codec context</span></span><br><span class="line">AVBufferRef* hw_device_ctx;</span><br><span class="line"><span class="built_in">av_hwdevice_ctx_create</span>(&amp;hw_device_ctx, device_type, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">codec_ctx-&gt;hw_device_ctx = <span class="built_in">av_buffer_ref</span>(hw_device_ctx);</span><br><span class="line"><span class="comment">// open stream</span></span><br></pre></td></tr></table></figure>

<p>一旦设置完成，解码是相当简单的；它仅仅是从源流种获取AVPacket并且将它们解码成AVFrames这些事情。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AVPacket* packet = <span class="built_in">av_packet_alloc</span>();</span><br><span class="line"><span class="built_in">av_read_frame</span>(format_ctx, packet);</span><br><span class="line"><span class="built_in">avcodec_send_packet</span>(codec_ctx, packet);</span><br><span class="line">AVFrame* frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"><span class="built_in">avcodec_receive_frame</span>(codec_ctx, frame);</span><br></pre></td></tr></table></figure>

<p>这些都是简化的，但组在一起也不需要太麻烦。虽然我还不能将它显示到屏幕上，我想验证是否生成有效的帧，所以我认为我只需将它们写入bitmap来验证。</p>
<p>这里有个小问题</p>
<h2 id="第二步：转换-NV12-为-RGBA"><a href="#第二步：转换-NV12-为-RGBA" class="headerlink" title="第二步：转换 NV12 为 RGBA"></a>第二步：转换 NV12 为 RGBA</h2><p>创建一个 bitmap(并且当它转换成功后，使用DX11 swapchain呈现)，我需要RGBA格式的帧。然后这个解码器解出来的是 NV12格式，所以我使用 FFmpeg的<a target="_blank" rel="noopener" href="https://ffmpeg.org/doxygen/0.5/swscale-example_8c-source.html">swscale</a>将 AV_PIX_FMT_NV12 转换成 AV_PIX_FMT_RGBA。</p>
<p>设置 SwsContext就像调用单个函数一样简单</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SwsContext* conversion_ctx = <span class="built_in">sws_getContext</span>(</span><br><span class="line">        SRC_WIDTH, SRC_HEIGHT, AV_PIX_FMT_NV12,</span><br><span class="line">        DST_WIDTH, DST_HEIGHT, AV_PIX_FMT_RGBA,</span><br><span class="line">        SWS_BICUBLIN | SWS_BITEXACT, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>当然，为了使用sws_scale(), 我们需要将帧数据从GPU转换到CPU. 利用ffmpeg的av_hwframe_transfer_data() 。有很多这样的<a target="_blank" rel="noopener" href="https://ffmpeg.org/doxygen/3.4/hw__decode_8c_source.html">例子</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decode frame</span></span><br><span class="line">AVFrame* sw_frame = <span class="built_in">av_frame_alloc</span>();</span><br><span class="line"><span class="built_in">av_hwframe_transfer_data</span>(sw_frame, frame, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">sws_scale</span>(conversion_ctx, sw_frame-&gt;data, sw_frame-&gt;linesize, </span><br><span class="line">          <span class="number">0</span>, sw_frame-&gt;height, dst_data, dst_linesize);</span><br><span class="line">sw_frame-&gt;data = dst_data</span><br><span class="line">sw_frame-&gt;linesize = dst_linesize</span><br><span class="line">sw_frame-&gt;pix_fmt = AV_PIX_FMT_RGBA</span><br><span class="line">sw_frame-&gt;width = DST_WIDTH</span><br><span class="line">sw_frame-&gt;height = DST_HEIGHT</span><br></pre></td></tr></table></figure>

<p>这样能正常工作，但作为一个长期解决方案有两个问题.</p>
<ol>
<li>我想从 AVFrame 得到是一个简单字节数组；使用”d3d11va” 给我们帧数据并不是简单字节数组。因此我将硬件名称改成 “dxva”. 通过这种方式，frame-&gt;data 就是 uint8_t* 形式的位图。目前它是有效的，但是作为一个长期解决方案，不使用 “d3d11va” 基本没抓住重点</li>
<li>当调用 sws_scale() 将帧转换成RGBA，我们需要将帧从GPU移动到CPU。确实，现在是有效的，但是很明显我们将这步移除</li>
</ol>
<p>所以无论如何都不是完美，但至少我们解出了帧，并以bitmap形式呈现到我们眼前。</p>
<h2 id="第三步：设置-DirectX11-渲染"><a href="#第三步：设置-DirectX11-渲染" class="headerlink" title="第三步：设置 DirectX11 渲染"></a>第三步：设置 DirectX11 渲染</h2><p>如果你还不知道，这是对你的忠告：DirectX11 是完全不同于 DirectX9，完全不同！</p>
<p>经过很多失败的尝试，我复制并粘贴了这个<a href="directxtutorial.com/Lesson.aspx?lessonid=11-4-5">示例</a>，这样我可以开始写代码了。之后将三角形编程了正方形的异常复杂的任务。</p>
<p>此外，我没有在运行时编译着色器，而是选择在编译时编译它们。有那么一瞬间，我想我必须包含一个第三方库才能做到这点。但是它只需要在CMakeList.txt文件中的几行代码。找到 fxc.exe 可执行文件，并使用适当的选项执行命令来编译着色器。（我使用 /Fh 将它们编译成自动生成的头文件）</p>
<h2 id="第四步：交换纹理颜色"><a href="#第四步：交换纹理颜色" class="headerlink" title="第四步：交换纹理颜色"></a>第四步：交换纹理颜色</h2><p>当我得到一个彩虹方块，只需在定义的输入布局中为 TEXCOORD 切换成 COLOR即可。显然，这意味着要改变一些事情：</p>
<ol>
<li>顶点结构现在有 <code>XMFLOAT2</code> (<em>x, y</em>)  对应纹理坐标映射值为 <code>XMFLOAT4</code> (<em>r</em>, <em>g</em>, <em>b</em>, <em>a</em>)</li>
<li>片段着色器需要从纹理中采样而不是我们直接提供颜色，这意味着我们需要一个 sampler</li>
<li>另外，<a target="_blank" rel="noopener" href="http://www.rastertek.com/dx11s2tut05.html">纹理坐标系和位置坐标系是不同的</a></li>
</ol>
<p>当我能渲染一张基础的静态图时，我知道我接近了，剩下的就是将实际位图从帧传输到共享纹理。</p>
<h2 id="第五步：渲染实际的帧"><a href="#第五步：渲染实际的帧" class="headerlink" title="第五步：渲染实际的帧"></a>第五步：渲染实际的帧</h2><p>因为我们的帧仍然是简单的RGBA字节数组，并且我们的 ID3D11Texture2D 是 DXGI_FORMAT_R8G8B8A8_UNORM 的格式。使用 memcpy 就可以了，我们需要根据计算得出来的数组长度：<code>width_in_pixels * height_in_pixels * bytes_per_pixel</code>.</p>
<p>注意我们同样需要调用device context’s <code>Map()</code> 获取能访问纹理底层数据的权限</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decode and convert frame</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> BYTES_IN_RGBA_PIXEL = <span class="number">4</span>;</span><br><span class="line">D3D11_MAPPED_SUBRESOURCE ms;</span><br><span class="line">device_context-&gt;<span class="built_in">Map</span>(m_texture.<span class="built_in">Get</span>(), <span class="number">0</span>, D3D11_MAP_WRITE_DISCARD, <span class="number">0</span>, &amp;ms);</span><br><span class="line"><span class="built_in">memcpy</span>(ms.pData, frame-&gt;data[<span class="number">0</span>], frame-&gt;width * frame-&gt;height * BYTES_IN_RGBA_PIXEL);</span><br><span class="line">device_context-&gt;<span class="built_in">Unmap</span>(m_texture.<span class="built_in">Get</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="comment">// clear the render target view, draw the indices, present the swapchain</span></span><br></pre></td></tr></table></figure>



<h2 id="第六步：渲染实际帧…-可能是正确的"><a href="#第六步：渲染实际帧…-可能是正确的" class="headerlink" title="第六步：渲染实际帧… 可能是正确的"></a>第六步：渲染实际帧… 可能是正确的</h2><p>从我的研究开始，我就知道使用 “d3d11va” 硬件加速解出来 AVFrame 可以使用 DirectX11 进行渲染。哪要怎么做呢？</p>
<p>我需要初始化 <strong>d3d11va hardware device context.</strong> 基本上，FFmpeg解码器需要了解它正在使用D3D11设备。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AVBufferRef* hw_device_ctx = <span class="built_in">av_hwdevice_ctx_alloc</span>(AV_HWDEVICE_TYPE_D3D11VA);</span><br><span class="line">AVHWDeviceContext* device_ctx = <span class="keyword">reinterpret_cast</span>&lt;AVHWDeviceContext*&gt;(hw_device_ctx-&gt;data);</span><br><span class="line">AVD3D11VADeviceContext* d3d11va_device_ctx = <span class="keyword">reinterpret_cast</span>&lt;AVD3D11VADeviceContext*&gt;(device_ctx-&gt;hwctx);</span><br><span class="line"><span class="comment">// m_device is our ComPtr&lt;ID3D11Device&gt;</span></span><br><span class="line">d3d11va_device_ctx-&gt;device = m_device.<span class="built_in">Get</span>();</span><br><span class="line"><span class="comment">// codec_ctx is a pointer to our FFmpeg AVCodecContext</span></span><br><span class="line">codec_ctx-&gt;hw_device_ctx = <span class="built_in">av_buffer_ref</span>(hw_device_ctx);</span><br><span class="line"><span class="built_in">av_hwdevice_ctx_init</span>(codec_ctx-&gt;hw_device_ctx);</span><br></pre></td></tr></table></figure>

<p>所以现在，当我把解出来的帧传到渲染器时，不需要将他们传输到CPU上，并且也不要将它们转成RGBA。我们可以简单地这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ComPtr&lt;ID3D11Texture2D&gt; texture = (ID3D11Texture2D*)frame-&gt;data[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>但是我们完成了么，并没有，还差很多。</p>
<p>我们需要将像素格式转成GPU。我们的交换链并没有神奇地开始渲染NV12帧，这意味着从NV12到RGBA转换需要在某个地方进行。现在，它将在GPU中进行，具体来说是在着色器中进行。这是合乎逻辑的；我们不仅是对纹理进行采样，因为纹理格式不是RGBA。为了让我们的着色器为每个像素返回正确的RGBA值，它需要根据纹理的YUV值来计算。</p>
<p>加入另一个着色器资源视图。当这个RGBA片段着色器将单个着色器资源视图作为输入，但是NV12片段着色器实际上需要两个：色度和亮度。因此，我们因此将一个纹理拆分成两个着色器资源视图。（在此之前，我不明白为什么DirectX需要区分纹理和着色器资源视图。天哪，我很高兴他们这样做了）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DXGI_FORMAT_R8_UNORM for NV12 luminance channel</span></span><br><span class="line">D3D11_SHADER_RESOURCE_VIEW_DESC luminance_desc = <span class="built_in">CD3D11_SHADER_RESOURCE_VIEW_DESC</span>(m_texture, D3D11_SRV_DIMENSION_TEXTURE2D, DXGI_FORMAT_R8_UNORM);</span><br><span class="line">m_device-&gt;<span class="built_in">CreateShaderResourceView</span>(m_texture, &amp;luminance_desc,  &amp;m_luminance_shader_resource_view); </span><br><span class="line"><span class="comment">// DXGI_FORMAT_R8G8_UNORM for NV12 chrominance channel</span></span><br><span class="line">D3D11_SHADER_RESOURCE_VIEW_DESC chrominance_desc = <span class="built_in">CD3D11_SHADER_RESOURCE_VIEW_DESC</span>(texture,  D3D11_SRV_DIMENSION_TEXTURE2D, DXGI_FORMAT_R8G8_UNORM);</span><br><span class="line">m_device-&gt;<span class="built_in">CreateShaderResourceView</span>(m_texture, &amp;chrominance_desc, &amp;m_chrominance_shader_resource_view);</span><br></pre></td></tr></table></figure>

<p>当然，我们还需要确保允许我们的片段着色器访问这些色度和亮度通道。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_device_context-&gt;<span class="built_in">PSSetShaderResources</span>(<span class="number">0</span>, <span class="number">1</span>, m_luminance_shader_resource_view.<span class="built_in">GetAddressOf</span>());</span><br><span class="line">m_device_context-&gt;<span class="built_in">PSSetShaderResources</span>(<span class="number">1</span>, <span class="number">1</span>, m_chrominance_shader_resource_view.<span class="built_in">GetAddressOf</span>());</span><br></pre></td></tr></table></figure>

<p>我们需要将纹理作为共享资源打开，这个ID3D11Texture2D 对象作为渲染器资源视图和FFmpeg 解出来帧的桥梁。我们将新解出来的帧复制到 ID3D11Texture2D 并且从中提取着色器资源视图。它是一种共享资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ComPtr&lt;IDXGIResource&gt; dxgi_resource;</span><br><span class="line">m_texture-&gt;<span class="built_in">QueryInterface</span>(__uuidof(IDXGIResource), <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(dxgi_resource.<span class="built_in">GetAddressOf</span>()));</span><br><span class="line">dxgi_resource-&gt;<span class="built_in">GetSharedHandle</span>(&amp;m_shared_handle);</span><br><span class="line">m_device-&gt;<span class="built_in">OpenSharedResource</span>(m_shared_handle, __uuidof(ID3D11Texture2D), <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>**&gt;(m_texture.<span class="built_in">GetAddressOf</span>()));</span><br></pre></td></tr></table></figure>

<p>我们需要改变我们接收复制纹理的方式。很显然每次渲染一帧时创建新的着色器资源视图代价是高昂。而且 <code>memcpy</code> 不再是一个选择因为我们无法简单访问纹理数据。我认为通过调用像 <code>CopySubresourceRegion</code> DirectX  函数来复制解出来的帧到纹理资源</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ComPtr&lt;ID3D11Texture2D&gt; new_texture = (ID3D11Texture2D*)frame-&gt;data[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> texture_index = frame-&gt;data[<span class="number">1</span>];</span><br><span class="line">m_device_context-&gt;<span class="built_in">CopySubresourceRegion</span>(</span><br><span class="line">        m_texture.<span class="built_in">Get</span>(), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">        new_texture.<span class="built_in">Get</span>(), texture_index, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>通过这些更改，我可以放心的告别那些 <code>av_hwframe_transfer_data()</code>和 <code>sws_scale()</code>这些函数，并且终于，向完全集成的FFmpeg-DirectX11视频播放器问好。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/mingxingren/2022/03/16/DirectX11Tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mingxingren/images/avatar01.png">
      <meta itemprop="name" content="mingxingren">
      <meta itemprop="description" content="挖一口自己的井">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingxingren的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mingxingren/2022/03/16/DirectX11Tutorial/" class="post-title-link" itemprop="url">DirectX11 Tutorial</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-16 23:06:23 / 修改时间：23:31:57" itemprop="dateCreated datePublished" datetime="2022-03-16T23:06:23+08:00">2022-03-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="DirectX11-Tutorial"><a href="#DirectX11-Tutorial" class="headerlink" title="DirectX11 Tutorial"></a>DirectX11 Tutorial</h2><h3 id="渲染Yuv纹理流程"><a href="#渲染Yuv纹理流程" class="headerlink" title="渲染Yuv纹理流程"></a>渲染Yuv纹理流程</h3><div id="flowchart-0" class="flow-chart"></div>





<h3 id="1-Direct3D初始化-创建ID3D11Device、ID3D11DeviceContext、IDXGISwapChain"><a href="#1-Direct3D初始化-创建ID3D11Device、ID3D11DeviceContext、IDXGISwapChain" class="headerlink" title="1. Direct3D初始化: 创建ID3D11Device、ID3D11DeviceContext、IDXGISwapChain"></a>1. Direct3D初始化: 创建ID3D11Device、ID3D11DeviceContext、IDXGISwapChain</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ID3D11Device: 显示适配器, 用于创建资源, 常用资源有: 资源类(ID3D11Resource 包括纹理和缓冲区), 视图类以及着色器. 还可以检测系统环境对功能支持</span><br><span class="line"></span><br><span class="line">ID3D11DeviceContext: D3D设备上下文, 可以看做是一个渲染管线. 渲染管线主要负责渲染和计算工作, 它需要绑定来自与它关联的ID3D11Device所创建的各种资源、视图和着色器才能正常运转, 初次之外，它还能够负责对资源的直接读写操作</span><br><span class="line"></span><br><span class="line">IDXGISwapChain: DXGI交换链, 缓存一个或多个表面(2D纹理), 它们都可以称为后备缓冲(backbuffer)的离屏纹理. 前台缓冲区(front buffer)为当前显示在屏幕上的帧.后备缓冲区是我们主要进行渲染的场所. 这些后备缓冲区通过合适的手段成为渲染管线的输出对象. 呈现(Present)有两种方法:</span><br><span class="line">① BitBlt Model(位块传输模型): 将后备缓冲区的数据进行BitBlt(位块传输, 即内容上的拷贝), 传入到DWM(桌面窗口管理器)与DX共享的后备缓冲, 然后进行翻转以显示其内容. 使用这种模型至少需要一个后备缓冲区。这时Win32应用程序最常用使用的方式, 在进行呈现后, 渲染管线仍然是对同一个后备缓冲区进行输出(支持Windows7 及 更高版本)</span><br><span class="line">② Flip Model(翻转模型): 该模型可以避免上一种方式多余复制, 后备缓冲区表面可以直接与DWM内的前台缓冲区进行翻转. 但是需要创建至少两个后备缓冲区, 并且每次完成呈现后通过代码切换到另一个后备缓冲区进行渲染. 该模型可以用于Win32应用程序已经UWP应用程序(需要DX1.2, 支持Window8 及 更高版本)</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建显示适配器和用于渲染的IDXGISwapChain</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * param pAdapter 视频适配器指针, 传递NULL以使用默认适配器(为IDXGIFactory1::EnumAdapters枚举的第一个适配器)</span></span><br><span class="line"><span class="comment">  * param DriverType 需要什么类型的驱动设备, 一般指 D3D_DRIVER_TYPE_HARDWARE </span></span><br><span class="line"><span class="comment">  * param Software 用于支持软件光栅化设备, 参数总是设定为NULL, 因为我们使用 D3D_DRIVER_TYPE_HARDWARE 类型即硬件渲染, 若使用此功能需要安装一个软件光栅化设备</span></span><br><span class="line"><span class="comment">  * param Flags 设备创建标志, 当以release模式生成程序时，该参数通常设为0（无附加标志值）；当以debug模式生成程序时，该参数应设为：D3D11_CREATE_DEVICE_DEBUG用以激活调试层</span></span><br><span class="line"><span class="comment">  * param pFeatureLevels 指向 D3D_FEATURE_LEVEL 数组的指针, 默认为NULL</span></span><br><span class="line"><span class="comment">  * param FeatureLevels pFeatureLevels数组长度</span></span><br><span class="line"><span class="comment">  * param SDKVersion SDK版本, 为 D3D11_SDK_VERSION</span></span><br><span class="line"><span class="comment">  * param pSwapChainDesc 初始化交换链参数</span></span><br><span class="line"><span class="comment">  * param ppSwapChain out</span></span><br><span class="line"><span class="comment">  * param ppDevice out</span></span><br><span class="line"><span class="comment">  * param pFeatureLevel 返回设备功能支持数组中第一个元素</span></span><br><span class="line"><span class="comment">  * param ppImmediateContext out</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function">HRESULT <span class="title">D3D11CreateDeviceAndSwapChain</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  IDXGIAdapter               *pAdapter,</span></span></span><br><span class="line"><span class="params"><span class="function">                  D3D_DRIVER_TYPE            DriverType,</span></span></span><br><span class="line"><span class="params"><span class="function">                  HMODULE                    Software,</span></span></span><br><span class="line"><span class="params"><span class="function">                  UINT                       Flags,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  <span class="keyword">const</span> D3D_FEATURE_LEVEL    *pFeatureLevels,</span></span></span><br><span class="line"><span class="params"><span class="function">                  UINT                       FeatureLevels,</span></span></span><br><span class="line"><span class="params"><span class="function">                  UINT                       SDKVersion,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  <span class="keyword">const</span> DXGI_SWAP_CHAIN_DESC *pSwapChainDesc,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] IDXGISwapChain             **ppSwapChain,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] ID3D11Device               **ppDevice,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] D3D_FEATURE_LEVEL          *pFeatureLevel,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] ID3D11DeviceContext        **ppImmediateContext</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="DXGI交换链与Direct3D设备的交互"><a href="#DXGI交换链与Direct3D设备的交互" class="headerlink" title="DXGI交换链与Direct3D设备的交互"></a>DXGI交换链与Direct3D设备的交互</h4><p>① 获取交换链后备缓冲区 <strong>ID3D11Texture2D</strong> 接口对象</p>
<p>② 为后备缓冲区创建一个<strong>ID3D11RenderTargetView</strong></p>
<p>③ 通过<strong>ID3D11Device</strong>创建一个<strong>ID3D11Texture2D</strong>用作深度/模板缓冲区, 要求与后备缓冲区等宽高</p>
<p>④ 创建深度/模板视图 <strong>ID3D11DepthStrenilView</strong>, 绑定上步创建的2D纹理</p>
<p>⑤ 通过<strong>ID3D11DeviceContext</strong>, 在渲染管线的输出合并阶段设置渲染目标</p>
<p>⑥ 在渲染管线的光栅化阶段设置好渲染的视图区域</p>
<p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2022031601.png" alt="image-01"></p>
<h3 id="2-IDXGISwapChain-创建-ID3D11Texture2D"><a href="#2-IDXGISwapChain-创建-ID3D11Texture2D" class="headerlink" title="2. IDXGISwapChain 创建 ID3D11Texture2D"></a>2. IDXGISwapChain 创建 ID3D11Texture2D</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回交换链得后台缓冲</span></span><br><span class="line"><span class="comment"> * param Buffer 从零开始缓冲区, 缓冲区数量由 DXGI_SWAP_CHAIN_DESC.BufferCount 指定</span></span><br><span class="line"><span class="comment"> * param riid in</span></span><br><span class="line"><span class="comment"> * param ppSurface out</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">HRESULT <span class="title">GetBuffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        UINT   Buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]  REFIID riid,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out] <span class="keyword">void</span>   **ppSurface</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="3-ID3D11Device-CreateRenderTargetView-创建渲染目标视图"><a href="#3-ID3D11Device-CreateRenderTargetView-创建渲染目标视图" class="headerlink" title="3.ID3D11Device::CreateRenderTargetView 创建渲染目标视图"></a>3.ID3D11Device::CreateRenderTargetView 创建渲染目标视图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建用于访问资源数据的渲染目标视图</span></span><br><span class="line"><span class="comment"> * param ID3D12Resource 指定了将要作为渲染目标的资源</span></span><br><span class="line"><span class="comment"> * param pDesc </span></span><br><span class="line"><span class="comment"> * param ppRTView out</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function">HRESULT <span class="title">CreateRenderTargetView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]            ID3D11Resource                      *pResource,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional]  <span class="keyword">const</span> D3D11_RENDER_TARGET_VIEW_DESC *pDesc,</span></span></span><br><span class="line"><span class="params"><span class="function">  [out, optional] ID3D11RenderTargetView              **ppRTView</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/X-Jun/p/9069608.html">DirectX11 With Windows SDK – 01 DirectX初始化</a></p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">start=>start: 开始
end=>end: 结束
op1=>operation: 创建 D3D11Device
op2=>operation: 创建 D3D11Swapchain
op3=>operation: 创建纹理 D3D11Texture
op4=>operation: 创建 ID3D11ShaderResourceView
op5=>operation: 创建渲染目标视图 CreateRenderTargetView
op6=>operation: 将渲染目标视图绑定到渲染管线 OMSetRenderTargets
op7=>operation: 创建 shader 字节码
op8=>operation: 创建 Vertex shader 对象 CreateVertexShader
op9=>operation: 创建 输入布局 CreateInputLayout
op10=>operation: 创建 Pixel shader 对象 CreatePixelShader

start->op1->op2->op3->op4->op5->op6->op7->op9->op10->end</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/mingxingren/2021/12/22/opengl%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mingxingren/images/avatar01.png">
      <meta itemprop="name" content="mingxingren">
      <meta itemprop="description" content="挖一口自己的井">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingxingren的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mingxingren/2021/12/22/opengl%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">OpenGL知识整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-22 00:40:00" itemprop="dateCreated datePublished" datetime="2021-12-22T00:40:00+08:00">2021-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-21 16:05:19" itemprop="dateModified" datetime="2022-06-21T16:05:19+08:00">2022-06-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="OpenGL-Sharders（着色器）"><a href="#OpenGL-Sharders（着色器）" class="headerlink" title="OpenGL Sharders（着色器）"></a>OpenGL Sharders（着色器）</h2><h3 id="GPU显示数据流程"><a href="#GPU显示数据流程" class="headerlink" title="GPU显示数据流程"></a>GPU显示数据流程</h3><p><img src="https://raw.githubusercontent.com/mingxingren/Notes/master/resource/photo/image-2021123001.png" alt="image-01"></p>
<h3 id="顶点着色器的坐标系统"><a href="#顶点着色器的坐标系统" class="headerlink" title="顶点着色器的坐标系统"></a>顶点着色器的坐标系统</h3><p>顶点着色器的坐标很有意思,  它使用 -1 和 1表示坐标系轴方向上的负边界和正边界.  仔细想想确实应该如此，假使我们想渲染的一块区域的大小是 10x10大小的矩形，那么边界就是 -5 ~ 5，当区域是20x20时，边界便改为 -10~10. 我猜如果以确定边界绘制左边代码便不具有普适性，这个矩形尺寸调整一下，那个矩形尺寸调整一下. 所以统一用 -1 和 1表示边界值, 中间值乘以系数表示其他坐标点，这样就不用受到渲染矩形区域大小的影响.</p>
<p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021120501.png" alt="image-01"></p>
<p>着色器（<strong>Shader</strong>）是运行在GPU上的小程序，这些小程序为图形渲染管线的某个特定部分而运行。使用一种叫 <strong>GLSL</strong> 的类C语言写成，一个典型的着色器有下面的结构</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version version_number</span></span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"><span class="keyword">in</span> type in_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> type out_variable_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> type uniform_name;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 处理输入并进行一些图形操作</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 输出处理过的结果到输出变量</span></span><br><span class="line">  out_variable_name = weird_stuff_we_processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="着色器数据输入"><a href="#着色器数据输入" class="headerlink" title="着色器数据输入"></a>着色器数据输入</h3><p>CPU数据通过OpenGL缓冲区发送到GPU</p>
<p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021123002.png" alt="image-02"></p>
<h4 id="glsl支持的数据类型"><a href="#glsl支持的数据类型" class="headerlink" title="glsl支持的数据类型"></a><a href="https://github.com/qyvlik/GLSL.qml/blob/master/glsl/GLSL%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.md">glsl支持的数据类型</a></h4><h2 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h2><p>应用程序使用单缓冲绘图时可能会存在图像闪烁的问题。 这是因为生成的图像不是一下子被绘制出来的，而是按照从左到右，由上而下逐像素地绘制而成的。最终图像不是在瞬间显示给用户，而是通过一步一步生成的，这会导致渲染的结果很不真实。为了规避这些问题，我们应用双缓冲渲染窗口应用程序。<strong>前</strong>缓冲保存着最终输出的图像，它会在屏幕上显示；而所有的的渲染指令都会在<strong>后</strong>缓冲上绘制。当所有的渲染指令执行完毕后，我们<strong>交换</strong>(Swap)前缓冲和后缓冲，这样图像就立即呈显出来，之前提到的不真实感就消除了。</p>
<h2 id="OpenGL-调用流程"><a href="#OpenGL-调用流程" class="headerlink" title="OpenGL 调用流程"></a>OpenGL 调用流程</h2><ol>
<li>着色器创建流程</li>
</ol>
<div id="flowchart-0" class="flow-chart"></div>

<ol start="2">
<li>创建 OpenGL 工程对象</li>
</ol>
<div id="flowchart-1" class="flow-chart"></div>

<ol start="3">
<li><p>申请顶点队列对象(VAO)、顶点缓冲对象(VBO)、索引缓冲对象(EBO), 细节参考: (<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiji333/article/details/114934590">https://blog.csdn.net/xiji333/article/details/114934590</a>)</p>
<div id="flowchart-2" class="flow-chart"></div>

<p>​    注：顶点缓冲区使用步骤：</p>
<p>​    </p>
<div id="flowchart-3" class="flow-chart"></div></li>
<li><p>使用 texture(纹理) 流程</p>
<div id="flowchart-4" class="flow-chart"></div></li>
</ol>
<p>片段着色器中的变量和我们程序申请的texture资源是通过纹理单元进行传值的. 其关系大致为：</p>
<div id="sequence-0"></div>

<p>注: OpenGL CPU像素数据向GPU纹理传输细节 —— <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dongguolei/p/11982230.html">glPixelStorei</a></p>
<p>注:  glActiveTexture 激活纹理单元后，调用 glBindTexture 会将 纹理绑定到纹理单元，此时如果再调用 glBindTexture 去操作其他纹理，那当前活跃的纹理单元就绑定为其他的纹理。故在要使用纹理的时候，一定要先 glActiveTexture 然后再 glBindTexture 。</p>
<h2 id="opengl-参考资料"><a href="#opengl-参考资料" class="headerlink" title="opengl 参考资料"></a>opengl 参考资料</h2><p><a target="_blank" rel="noopener" href="https://antongerdelan.net/opengl/index.html#onlinetuts">https://antongerdelan.net/opengl/index.html#onlinetuts</a></p>
<h2 id="片段着色器变量"><a href="#片段着色器变量" class="headerlink" title="片段着色器变量"></a>片段着色器变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gl_FragCoord: 记录顶点在窗体的实际坐标, x和y分量是片段的窗口空间(Window-space)坐标, 原点为窗口左下角</span><br><span class="line"></span><br><span class="line">gl_FrontFacing: 当不启用面剔除 (GL_FACE_CULL), gl_FrontFacing 将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分</span><br><span class="line"></span><br><span class="line">gl_FragDepth: 可以设置的当前片段的深度值, 如果着色器没有写入值到gl_FragDepth，它会自动取用gl_FragCoord.z的值</span><br></pre></td></tr></table></figure>

<h2 id="接口块"><a href="#接口块" class="headerlink" title="接口块"></a>接口块</h2><p>接口块的声明和 <code>struct</code> 的声明有点想象，不同的是，现在 根据它是一个输入还是输出块(Block), 使用 <code>in</code> 和 <code>out</code> 关键字来定义</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vertex shader</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec2</span> aTexCoords;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> view;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> projection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; vs_out;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);    </span><br><span class="line">    vs_out.TexCoords = aTexCoords;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pixel shader</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> VS_OUT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec2</span> TexCoords;</span><br><span class="line">&#125; fs_in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> <span class="built_in">texture</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;             </span><br><span class="line">    FragColor = <span class="built_in">texture</span>(<span class="built_in">texture</span>, fs_in.TexCoords);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="uniform-缓冲对象"><a href="#uniform-缓冲对象" class="headerlink" title="uniform 缓冲对象"></a>uniform 缓冲对象</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">std140</span>) <span class="keyword">uniform</span> Matrices</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">mat4</span> projection;</span><br><span class="line">    <span class="type">mat4</span> view;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> model;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">gl_Position</span> = projection * view * model * <span class="type">vec4</span>(aPos, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>uniform buffer object 比 独立的uniform的好处:</p>
<p>① 一次设置很多 uniform会比一个一个设置要快很多</p>
<p>② 可以同时修改多个 shader程序中的 uniform 变量</p>
<p>③ 如果使用Uniform缓冲对象的话，你可以在着色器中使用更多的uniform。OpenGL限制了它能够处理的uniform数量，这可以通过GL_MAX_VERTEX_UNIFORM_COMPONENTS来查询</p>
<h2 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h2><p>几何着色器的输入是一个的图元(如点或者三角形)的一组顶点, 可以在顶点发送到下一个着色器阶段之前对他们随意变换.</p>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>在需要渲染大量物体时, 非常消耗性能. 与绘制顶点本身相比，使用 <code>glDrawArrays</code>和 <code>glDrawElements</code> 函数告诉GPU去绘制你的顶点数据会消耗更多的性能, 因为 OpenGL 绘制顶点数据前需要做很多工作(比如告诉GPU该从哪个缓冲读取数据, 从哪寻找顶点数据属性, 而且这些都是在相对缓慢的CPU到GPU总线上进行的).</p>
<p>而实例化能够降数据一次性发给GPU, 然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* glDrawArraysInstanced 绘画多个一组顶点的实例</span></span><br><span class="line"><span class="comment">* @param mode 指出要画的基本形状</span></span><br><span class="line"><span class="comment">* @param first 顶点数据起点</span></span><br><span class="line"><span class="comment">* @param count 基本形状需要使用的顶点数据</span></span><br><span class="line"><span class="comment">* @param instancecount 要绘画的实例数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glDrawArraysInstanced</span><span class="params">(GLenum mode, GLint first, GLsizei count, GLsizei instancecount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* glDrawElementsInstanced 绘画多个元素集合形式的实例</span></span><br><span class="line"><span class="comment">* @param mode 指出要画的基本形状</span></span><br><span class="line"><span class="comment">* @param count 表示一个实例需要的元素数量</span></span><br><span class="line"><span class="comment">* @param type 元素类型</span></span><br><span class="line"><span class="comment">* @param indices 元素起始位置</span></span><br><span class="line"><span class="comment">* @param instancecount 实例数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glDrawElementsInstanced</span><span class="params">(GLenum mode, GLsizei count, GLenum type, <span class="keyword">const</span> <span class="keyword">void</span> * indices, GLsizei instancecount)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="实例化数组"><a href="#实例化数组" class="headerlink" title="实例化数组"></a>实例化数组</h2><p>定义为一个顶点属性(能够让我们存储更多的数据), 仅在顶点着色器渲染一个新的实例时才会更新</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* glVertexAttribDivisor 修改实例化渲染时通用顶点数据更新速度</span></span><br><span class="line"><span class="comment">* @param index 输入顶点的index</span></span><br><span class="line"><span class="comment">* @param divisor 除数, 描述每渲染几个实例顶点数据更新成下一个, 为 0 时表示每一个顶点都会更新数据而不是每个实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">glVertexAttribDivisor</span><span class="params">(GLuint index,GLuint divisor)</span></span>;</span><br></pre></td></tr></table></figure>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">start=>start: Start
op_1=>operation: glCreateShader 创建着器句柄
op_2=>operation: glShaderSource 加载着色器脚本
op_3=>operation: glCompileShader 编译着色器脚本
op_4=>operation: glGetShaderiv 判断着色器编译结果是否成功
op_5=>operation: glGetShaderInfoLog 获取着色器信息日志
cond=>condition: 是否成功
end=>end
start->op_1->op_2->op_3->op_4->cond
cond(yes)->end
cond(no)->op_5->end</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: Start
op_1=>operation: glCreateProgram 创建工程对象
op_2=>operation: glAttachShader 加载顶点着色器,片段着色器
op_3=>operation: glLinkProgram 构建工程
op_4=>operation: glGetProgramiv 获取工程构建状态
op_5=>operation: glDeleteShader 删除着色器
op_6=>operation: glGetProgramInfoLog 获取工程日志
cond=>condition: 是否成功
e=>end
st->op_1->op_2->op_3->op_4->cond
cond(yes)->op_5->e
cond(no)->op_6->e</textarea><textarea id="flowchart-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><textarea id="flowchart-2-code" style="display: none">   st=>start: Start
   op_1=>operation: glGenVertexArrays 申请顶点队列对象(VAO)
   op_2=>operation: glGetBuffer 创建VBO(顶点缓冲对象) EBO(索引缓冲对象)等缓冲对象
   op_3=>operation: glBindVertexArray 将当前执行对象绑定到VAO
   op_4=>operation: glBindData 将VBO绑定到VAO上,并将当前操作对象指向VBO
   op_5=>operation: glBufferData 对VBO EBO填入数据
   op_6=>operation: glVertexAttribPointer 将location id 绑定到当前的 VBO 缓存
   op_7=>operation: glDrawElements 根据 EBO 画出图形
   e=>end: End
   st->op_1->op_2->op_3->op_4->op_5->op_6->op_7->e</textarea><textarea id="flowchart-2-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-2", options);</script><textarea id="flowchart-3-code" style="display: none">   st=>start: Start
   op_1=>operation: 获取缓冲区标识: glGenBuffers(GLsizei n, GLuint* buffers);
   op_2=>operation: 绑定缓冲区对象: glBindBuffer(GLenum target, GLuint buffer);
   op_3=>operation: 用数据填充缓冲区: glBufferData(GLenum target, GLsizeiptr size, const void* data, GLenum usage)
   op_4=>operation: 更新缓冲数据: glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void*  data);
   op_5=>operation: 清楚缓冲区对象 glDeleteBuffers(GLsizei n, const GLuint* buffers);
   e=>end: End
   st->op_1->op_2->op_3->op_4->op_5->e</textarea><textarea id="flowchart-3-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-3-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-3", options);</script><textarea id="flowchart-4-code" style="display: none">   st=>start: Start
   op_1=>operation: glGenTextures 申请 texture 对象
   op_2=>operation: glBindTexture 绑定当前需要操作的 texture
   op_3=>operation: glTexParameteri 设置 texture 属性?
   op_4=>operation: glTexImage2D 对 texture 填入数据
   op_5=>operation: glGenerateMipmap 生成 mipmap https://zh.wikipedia.org/wiki/Mipmap
   op_6=>operation: glUniform1i 特殊用法: 将 片段着色器中 texture变量 指定为对应的纹理单元
   op_7=>operation: glActiveTexture 激活纹理单元例如:GL_TEXTURE0, 并设置成当前操作的纹理单元
   op_8=>operation: glBindTexture 将我们申请的texture对象绑定到当前的纹理单元中
   e=>end: End
   st->op_1->op_2->op_3->op_4->op_5->op_6->op_7->op_8->e</textarea><textarea id="flowchart-4-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-4-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-4", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">fs texture变量->texture unit: 绑定对应的纹理单元
程序 texture对象资源->texture unit: 程序申请的texture资源输入到纹理单元
texture unit->fs texture变量: 映射</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/mingxingren/2021/11/25/imgui%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mingxingren/images/avatar01.png">
      <meta itemprop="name" content="mingxingren">
      <meta itemprop="description" content="挖一口自己的井">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingxingren的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mingxingren/2021/11/25/imgui%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">imgui接口说明文档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-11-25 23:22:00" itemprop="dateCreated datePublished" datetime="2021-11-25T23:22:00+08:00">2021-11-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-27 20:27:46" itemprop="dateModified" datetime="2022-03-27T20:27:46+08:00">2022-03-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Dear-Imgui-Ui部分的API说明"><a href="#Dear-Imgui-Ui部分的API说明" class="headerlink" title="Dear Imgui Ui部分的API说明"></a>Dear Imgui Ui部分的API说明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始新的一帧，可以提交任何指令直到调用 Render()/EndFrame()</span></span><br><span class="line"><span class="function">IMGUI_API <span class="keyword">void</span> <span class="title">NewFrame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 window 入栈并且开始调用命令修饰它，直到调用 End 让 window 出栈</span></span><br><span class="line"><span class="comment">// 当 bool *p_open！= NULL, 窗体右上角会有关闭选项, 点击这个选项会设置p_open为false</span></span><br><span class="line"><span class="comment">// 可以在同一帧调用多次 Begin()/End() 来对同一个窗体进行多次操作，前提是 name 相同</span></span><br><span class="line"><span class="comment">// 像 flags 或者 p_open 只在第一次调用 Begin() 起作用</span></span><br><span class="line"><span class="comment">// Begin() 返回 false 表示窗口已折叠或完全裁剪，因此可以提前退出并省略提交</span></span><br><span class="line"><span class="comment">// [重要提示: 由于遗留问题，这与大多数其他函数如 BeginMenu/EndMenu、BeginPopup/EndPopup 等不一致</span></span><br><span class="line"><span class="comment">// , 只有在相应的 BeginXXX函数返回 true 时才应调用 EndXXX 调用. Begin 和 BeginChild 是唯一奇数. </span></span><br><span class="line"><span class="comment">// 将在未来的更新中修复]</span></span><br><span class="line"><span class="comment">// 请注意，窗口堆栈的底部始终包含一个名为&quot;调试&quot;的窗口</span></span><br><span class="line"><span class="function">IMGUI_API <span class="keyword">bool</span> <span class="title">Begin</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">bool</span>* p_open = <span class="literal">NULL</span>, ImGuiWindowFlags flags = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ImGuiWindowFlags 说明</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ImGuiWindowFlags_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ImGuiWindowFlags_None                   = <span class="number">0</span>,</span><br><span class="line">    ImGuiWindowFlags_NoTitleBar             = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,   <span class="comment">// 禁用标题栏</span></span><br><span class="line">    ImGuiWindowFlags_NoResize               = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">// 禁止用户调整通过右下角调整大小</span></span><br><span class="line">    ImGuiWindowFlags_NoMove                 = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,   <span class="comment">// 禁止用户移动窗体</span></span><br><span class="line">    ImGuiWindowFlags_NoScrollbar            = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,   <span class="comment">// 禁止滚动条 (window can still scroll with mouse or programmatically)</span></span><br><span class="line">    ImGuiWindowFlags_NoScrollWithMouse      = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,   <span class="comment">// 禁止用户使用鼠标滚轮垂直滚动. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.</span></span><br><span class="line">    ImGuiWindowFlags_NoCollapse             = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,   <span class="comment">// 禁止用户通过双击折叠窗口</span></span><br><span class="line">    ImGuiWindowFlags_AlwaysAutoResize       = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 窗体大小自适应每帧内容</span></span><br><span class="line">    ImGuiWindowFlags_NoBackground           = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,   <span class="comment">// 禁止画背景和边框. Similar as using SetNextWindowBgAlpha(0.0f).</span></span><br><span class="line">    ImGuiWindowFlags_NoSavedSettings        = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,   <span class="comment">// Never load/save settings in .ini file</span></span><br><span class="line">    ImGuiWindowFlags_NoMouseInputs          = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 禁止捕捉鼠标, hovering test with pass through.</span></span><br><span class="line">    ImGuiWindowFlags_MenuBar                = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  <span class="comment">// 有一个菜单栏</span></span><br><span class="line">    ImGuiWindowFlags_HorizontalScrollbar    = <span class="number">1</span> &lt;&lt; <span class="number">11</span>,  <span class="comment">// 允许有一个水平滚动条 (默认关闭). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the &quot;Horizontal Scrolling&quot; section.</span></span><br><span class="line">    ImGuiWindowFlags_NoFocusOnAppearing     = <span class="number">1</span> &lt;&lt; <span class="number">12</span>,  <span class="comment">// 从隐藏状态转换为可见状态时禁用获取焦点</span></span><br><span class="line">    ImGuiWindowFlags_NoBringToFrontOnFocus  = <span class="number">1</span> &lt;&lt; <span class="number">13</span>,  <span class="comment">// Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)</span></span><br><span class="line">    ImGuiWindowFlags_AlwaysVerticalScrollbar= <span class="number">1</span> &lt;&lt; <span class="number">14</span>,  <span class="comment">// 总是显示垂直滚动条(even if ContentSize.y &lt; Size.y)</span></span><br><span class="line">    ImGuiWindowFlags_AlwaysHorizontalScrollbar=<span class="number">1</span>&lt;&lt; <span class="number">15</span>,  <span class="comment">// 总是显示水平滚动条 (even if ContentSize.x &lt; Size.x)</span></span><br><span class="line">    ImGuiWindowFlags_AlwaysUseWindowPadding = <span class="number">1</span> &lt;&lt; <span class="number">16</span>,  <span class="comment">// 使用style.Window Padding 确保子窗体没有边框 (ignored by default for non-bordered child windows, because more convenient)</span></span><br><span class="line">    ImGuiWindowFlags_NoNavInputs            = <span class="number">1</span> &lt;&lt; <span class="number">18</span>,  <span class="comment">// 窗口内没有游戏手柄/键盘导航</span></span><br><span class="line">    ImGuiWindowFlags_NoNavFocus             = <span class="number">1</span> &lt;&lt; <span class="number">19</span>,  <span class="comment">// No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)</span></span><br><span class="line">    ImGuiWindowFlags_UnsavedDocument        = <span class="number">1</span> &lt;&lt; <span class="number">20</span>,  <span class="comment">// Display a dot next to the title. When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.</span></span><br><span class="line">    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,</span><br><span class="line">    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,</span><br><span class="line">    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [Internal]</span></span><br><span class="line">    ImGuiWindowFlags_NavFlattened           = <span class="number">1</span> &lt;&lt; <span class="number">23</span>,  <span class="comment">// [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)</span></span><br><span class="line">    ImGuiWindowFlags_ChildWindow            = <span class="number">1</span> &lt;&lt; <span class="number">24</span>,  <span class="comment">// Don&#x27;t use! For internal use by BeginChild()</span></span><br><span class="line">    ImGuiWindowFlags_Tooltip                = <span class="number">1</span> &lt;&lt; <span class="number">25</span>,  <span class="comment">// Don&#x27;t use! For internal use by BeginTooltip()</span></span><br><span class="line">    ImGuiWindowFlags_Popup                  = <span class="number">1</span> &lt;&lt; <span class="number">26</span>,  <span class="comment">// Don&#x27;t use! For internal use by BeginPopup()</span></span><br><span class="line">    ImGuiWindowFlags_Modal                  = <span class="number">1</span> &lt;&lt; <span class="number">27</span>,  <span class="comment">// Don&#x27;t use! For internal use by BeginPopupModal()</span></span><br><span class="line">    ImGuiWindowFlags_ChildMenu              = <span class="number">1</span> &lt;&lt; <span class="number">28</span>   <span class="comment">// Don&#x27;t use! For internal use by BeginMenu()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [Obsolete]</span></span><br><span class="line">    <span class="comment">//ImGuiWindowFlags_ResizeFromAnySide    = 1 &lt;&lt; 17,  // --&gt; Set io.ConfigWindowsResizeFromEdges=true and make sure mouse cursors are supported by backend (io.BackendFlags &amp; ImGuiBackendFlags_HasMouseCursors)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出框: 打开 / 关闭 功能</span></span><br><span class="line"><span class="comment">// - OpenPopup(): 设置弹出框为打开, ImGuiPopupFlags 可用于打开选项</span></span><br><span class="line"><span class="comment">// - If not modal: 通过点击其他地方关闭弹出框 或者 点击 ESCAPE</span></span><br><span class="line"><span class="comment">// - CloseCurrentPopup(): 在 BeginPopup 到 EndPopup 命令执行中，调用 CloseCurrentPopup 可以手动关闭, 当 Selectable()/MenuItem() 激活时, CloseCurrentPopup()默认被调用 </span></span><br><span class="line"><span class="comment">// - Use ImGuiPopupFlags_NoOpenOverExistingPopup to avoid opening a popup if there&#x27;s already one at the same level. This is equivalent to e.g. testing for !IsAnyPopupOpen() prior to OpenPopup().</span></span><br><span class="line"><span class="comment">// - 在BeginPopup() 之后使用 IsWindowAppearing() 判断窗口是否刚刚打开</span></span><br><span class="line"><span class="function">IMGUI_API <span class="keyword">void</span> <span class="title">OpenPopup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_id, ImGuiPopupFlags popup_flags = <span class="number">0</span>)</span></span>;	<span class="comment">// call to mark popup as open (don&#x27;t call every frame!).</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出层, 模态</span></span><br><span class="line"><span class="comment">// - 会阻塞 调用 后面的鼠标悬停检测(以及大多数鼠标交互)</span></span><br><span class="line"><span class="comment">// - if not modal: 通过点击其他地方关闭弹出框 或者 点击 ESCAPE</span></span><br><span class="line"><span class="comment">// - 可见性状态 (~bool) 是在内部保存的, 并不是被调用者保存</span></span><br><span class="line"><span class="comment">// - 上面的三个属性是相关的: 我们需要在库中保留弹出窗口可见性状态，因为弹出窗口可能随时关闭</span></span><br><span class="line"><span class="comment">// - 可以调用 IsItemHovered() or IsWindowHovered() 时使用 ImGuiHoveredFlags_AllowWhenBlockedByPopup 来绕过悬停限制</span></span><br><span class="line"><span class="comment">// - 重要提示: Popup 标识符时相对于当前 ID 堆栈的, 因此 OpenPopup 和 BeginPopup 一般需要在堆栈的同一级别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Popups: begin/end functions</span></span><br><span class="line"><span class="comment">// -BeginPopup(): 查询弹出状态, 如果打开就附加到 window. 之后调用 EndPopup(). ImGuiWindowFlags 被转发到window</span></span><br><span class="line"><span class="comment">// -BeginPopupModal():  block every interactions behind the window, cannot be closed by user, add a dimming background, has a title bar.</span></span><br><span class="line"><span class="function">IMGUI_API <span class="keyword">bool</span> <span class="title">BeginPopup</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str_id, ImGuiWindowFlags flags = <span class="number">0</span>)</span></span>;	<span class="comment">// return true if the popup is open, and you can start outputting to it.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/mingxingren/2021/10/12/rust%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mingxingren/images/avatar01.png">
      <meta itemprop="name" content="mingxingren">
      <meta itemprop="description" content="挖一口自己的井">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingxingren的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mingxingren/2021/10/12/rust%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" class="post-title-link" itemprop="url">rust知识整理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-10-12 11:07:00" itemprop="dateCreated datePublished" datetime="2021-10-12T11:07:00+08:00">2021-10-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-20 20:16:37" itemprop="dateModified" datetime="2021-10-20T20:16:37+08:00">2021-10-20</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>Rust 的克隆与复制</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/21730929">https://zhuanlan.zhihu.com/p/21730929</a></p>
<ol start="2">
<li><p>Rust 提供了分层式处理错误方案：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Option</span>&lt;T&gt;: 用于处理有值和无值的情况</span><br><span class="line"><span class="built_in">Result</span>&lt;T, E&gt;: 用于处理可恢复错误的情况</span><br><span class="line">Panic: 用于处理不可恢复错误的情况</span><br><span class="line">Abort: 用于处理会发生灾难性后果的情况</span><br></pre></td></tr></table></figure></li>
<li><p>生命周期注解位于引用的 <strong>&amp;</strong> 操作符之后，并用一个空格将生命周期注解与引用类型分隔开，比如 <strong>&amp; ‘a i32</strong>  、 <strong>&amp;’a mut i32</strong>、**&amp;’a str** 。生周期注解并不改变任何引用的生命周期的大小，只用于描述多个生命周期间的关系。</p>
</li>
</ol>
<ol start="4">
<li><p><strong>async</strong> 关键字作用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 1. 允许函数体内使用 .await 语法</span><br><span class="line">// 2. 修改函数的返回类型。 async fn foo() -&gt; Bar 实际上返回的是 impl std::future::Future&lt;Output=Bar&gt;</span><br><span class="line">// 3. 自动将返回值封装进一个新的 future 对象</span><br></pre></td></tr></table></figure>

<p><strong>.await</strong> 语法的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="5">
<li><p><strong>C/CPP Type to Rust</strong></p>
<p>参考：<a target="_blank" rel="noopener" href="https://locka99.gitbooks.io/a-guide-to-porting-c-to-rust/content/features_of_rust/types.html">https://locka99.gitbooks.io/a-guide-to-porting-c-to-rust/content/features_of_rust/types.html</a></p>
<table>
<thead>
<tr>
<th align="center">C/C++</th>
<th align="center">Rust</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">i8(or u8)</td>
</tr>
<tr>
<td align="center">unsigned char</td>
<td align="center">u8</td>
</tr>
<tr>
<td align="center">signed char</td>
<td align="center">i8</td>
</tr>
<tr>
<td align="center">short int</td>
<td align="center">i16</td>
</tr>
<tr>
<td align="center">unsigned short int</td>
<td align="center">u16</td>
</tr>
<tr>
<td align="center">(signed)  int</td>
<td align="center">i32 or i16</td>
</tr>
<tr>
<td align="center">unsigned int</td>
<td align="center">u32 or u16</td>
</tr>
<tr>
<td align="center">(signed) long int</td>
<td align="center">i32<code>or</code>i64</td>
</tr>
<tr>
<td align="center">unsigned long int</td>
<td align="center">u32<code>or</code>u64</td>
</tr>
<tr>
<td align="center">(signed) long long int</td>
<td align="center">i64</td>
</tr>
<tr>
<td align="center">size_t</td>
<td align="center">usize</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">f32</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">f64</td>
</tr>
<tr>
<td align="center">long double</td>
<td align="center">f128<br />(Rust 在有些平台上不支持该类型)</td>
</tr>
<tr>
<td align="center">bool</td>
<td align="center">bool</td>
</tr>
<tr>
<td align="center">void</td>
<td align="center">()</td>
</tr>
</tbody></table>
<p>C 的 <code>&lt;stdin.h&gt;</code>  头文件提供具有长度签名的类型别名（推荐使用）</p>
<table>
<thead>
<tr>
<th align="center">C/CPP</th>
<th align="center">Rust</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int8_t</td>
<td align="center">i8</td>
</tr>
<tr>
<td align="center">uint8_t</td>
<td align="center">u8</td>
</tr>
<tr>
<td align="center">int16_t</td>
<td align="center">i16</td>
</tr>
<tr>
<td align="center">uint16_t</td>
<td align="center">u16</td>
</tr>
<tr>
<td align="center">int32_t</td>
<td align="center">i32</td>
</tr>
<tr>
<td align="center">uint32_t</td>
<td align="center">u32</td>
</tr>
<tr>
<td align="center">int64_t</td>
<td align="center">i64</td>
</tr>
<tr>
<td align="center">uint64_t</td>
<td align="center">u64</td>
</tr>
</tbody></table>
<p>Rust FFI编程——手动绑定C库</p>
<p><a target="_blank" rel="noopener" href="https://rustcc.cn/article?id=f70a81d1-cb79-4429-985c-d3d53247f5c0">https://rustcc.cn/article?id=f70a81d1-cb79-4429-985c-d3d53247f5c0</a></p>
</li>
</ol>
<ol start="6">
<li><strong>rust 指针转换</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rust *mut u8 转换成 &amp;[u8]</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// data_ptr为 *mut u8, data为 &amp;[u8]</span></span><br><span class="line">    <span class="comment">// 使用 slice::from_raw_parts 不会发生拷贝，作用给这块内存创建一个切片</span></span><br><span class="line">    <span class="keyword">let</span> data = slice::from_raw_parts(data_ptr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rust *mut u8 转换成 &amp;mut [u8]</span></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="comment">// data_ptr为 *mut u8, data为 Vec[u8]</span></span><br><span class="line">    <span class="comment">// 使用 Vec::from_raw_parts 不会发生拷贝，该块内存的所有权会被 data 接管</span></span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">Vec</span>::from_raw_parts(data_ptr, size, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>7.原始指针</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &amp;<span class="number">56</span>;</span><br><span class="line"><span class="keyword">let</span> a_raw_ptr = a <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">u32</span>;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">let</span> b = &amp;<span class="keyword">mut</span> <span class="number">5634.3</span>;</span><br><span class="line"><span class="keyword">let</span> b_mut_ptr = b <span class="keyword">as</span> *<span class="keyword">mut</span> T;</span><br></pre></td></tr></table></figure>



<p>8.rust 智能指针</p>
<blockquote>
<ul>
<li>独占式智能指针 <code>Box&lt;T&gt;</code></li>
<li>非线程安全的引用计数智能指针 <code>Rc&lt;T&gt;</code></li>
<li>线程安全的引用计数智能指针 <code>Arc&lt;T&gt;</code></li>
<li>弱指针 <code>Weak&lt;T&gt;</code></li>
</ul>
</blockquote>
<ol start="9">
<li>rust <strong>async/await</strong>作用理解： <strong>async</strong> 关键字将一个代码块转为为实现了<strong>future</strong>特征的状态机，使得在同步方法中调用阻塞函数（<strong>async</strong>转化的函数会阻塞整个线程），但是阻塞的<strong>future</strong>会让出线程控制权，允许其他<strong>future</strong>运行；而<strong>await</strong>关键字可以使<strong>async</strong>代码块中的其他<strong>async</strong>函数按顺序执行，当<strong>await</strong>发生阻塞时，不会阻塞当前线程，可以让其他任务执行。</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/144325440">https://zhuanlan.zhihu.com/p/144325440</a></p>
<p>异步测试代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此代码可以使task1 和 task2并发执行，根据 rust tokio调度器进行调度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[tokio::main]</span>		<span class="comment">// basic_scheduler threaded_scheduler </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; <span class="built_in">Result</span>&lt;(), <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Error&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// task1</span></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;########## &#123;&#125; current thread: &#123;:?&#125;&quot;</span>, <span class="number">1</span>, std::thread::current().id());</span><br><span class="line">        tokio::time::sleep(Duration::from_millis(<span class="number">3000</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;########## &#123;&#125; currnet end&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处休眠给 task1 进入 await状态时间, 交出它所在线程的执行权, </span></span><br><span class="line">    <span class="comment">// 使得task1和task2在同一个线程并发执行. 若不加，可能两个任务会</span></span><br><span class="line">    <span class="comment">// 分别在不同的线程中执行</span></span><br><span class="line">    tokio::time::sleep(Duration::from_millis(<span class="number">200</span>)).<span class="keyword">await</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// task2</span></span><br><span class="line">    tokio::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;########## &#123;&#125; current thread: &#123;:?&#125;&quot;</span>, <span class="number">2</span>, std::thread::current().id());</span><br><span class="line">        tokio::time::sleep(Duration::from_millis(<span class="number">1000</span>)).<span class="keyword">await</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;########## &#123;&#125; current end&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tokio::time::sleep(Duration::from_millis(<span class="number">10000</span>)).<span class="keyword">await</span>;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="10">
<li><p>Box 可以在堆上申请内存，当我们想解除 Box 获取内存时代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box_data_raw_ptr = <span class="built_in">Box</span>::into_raw(box_data);</span><br></pre></td></tr></table></figure>

<p>使用此方法后，Box 变量变回失效，不能再使用。</p>
<p>如果想把一块无人管理的内存转给 Box 管理，代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> box_data_raw_ptr = <span class="built_in">Box</span>::into_raw(box_data);</span><br><span class="line"><span class="keyword">let</span> box_data_ptr = <span class="keyword">unsafe</span> &#123; <span class="built_in">Box</span>::from_raw(box_data_raw_ptr) &#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>Rust <strong>mod关键字</strong>作用：</p>
<p>① 在当前目录下寻找 <strong>xxx.rs</strong> 文件。因为一个 rust 文件可以看成一个 module.</p>
<p>② 在当前目录下寻找 <strong>xxx/mod.rs</strong> 文件。此时 services 可以看做是一个命名空间.</p>
</li>
</ol>
<ol start="12">
<li> Rust <strong>Cell</strong> 和 <strong>RefCell</strong> 的作用就是在提供结构体在不可变的时候，可以修改其中的某个成员.</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/mingxingren/2021/08/19/C%E5%92%8CC++%E7%9A%84%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mingxingren/images/avatar01.png">
      <meta itemprop="name" content="mingxingren">
      <meta itemprop="description" content="挖一口自己的井">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingxingren的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mingxingren/2021/08/19/C%E5%92%8CC++%E7%9A%84%E7%BC%96%E7%A8%8B%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">C/C++的编程问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-19 17:26:00" itemprop="dateCreated datePublished" datetime="2021-08-19T17:26:00+08:00">2021-08-19</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-06-21 17:13:24" itemprop="dateModified" datetime="2022-06-21T17:13:24+08:00">2022-06-21</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>宏定义 ’**#<strong>‘ 和 ’</strong>##<strong>‘ 的使用说明: ‘</strong>#<strong>‘ 用于将代码转换成字符串; ‘</strong>##**’ 用于拼接代码; 使用范例:</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PrintCode(x) #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INT_TYPE(x) int##x##_t</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">PrintCode</span>(<span class="keyword">int</span>) &lt;&lt; std::endl;    <span class="comment">// 输出: int</span></span><br><span class="line">    <span class="built_in">INT_TYPE</span>(<span class="number">64</span>) a;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(a) &lt;&lt; std::endl;    <span class="comment">// 输出 8 因为 a是 int64_t</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>预处理指令</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FALSE    <span class="comment">// 相当于 C语言中 if</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> TRUE    <span class="comment">// 相当于 C语言中 else if</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>        <span class="comment">// 相当于 C语言中 else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>C/C++ 不使用结构体字节对齐</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*减小内存占用的空间；结构体默认进行对齐，占用的空间比结构体内部成员变量字节加起来大，如果取消字节对齐，可以减小一部分空间。见下面具体例子。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">直接将结构体作为通信协议（在低带宽下通讯）；在不同的平台下，保证结构体内基本数据的长度相同，同时取消结构体的对齐，就可以将定义的数据格式结构体直接作为数据通信协议使用。*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack (n)  <span class="comment">// 编译器将按照n个字节对齐；</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()   <span class="comment">// 恢复先前的pack设置,取消设置的字节对齐方式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack(pop)<span class="comment">// 恢复先前的pack设置,取消设置的字节对齐方式</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  pack(1)  <span class="comment">// 按1字节进行对齐 即：不行进行对齐</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>GUN C 允许声明长度为0的数组，零长度数组可用作结构的最后一个元素，该结构实际上是可变长度对象的标头，内存分配如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="keyword">char</span> contents[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span> *<span class="title">thisline</span> =</span> (struct line *)<span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (struct line) + this_length * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">thisline-&gt;length = this_length;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>typedef 的前置声明：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> object defMyObject;</span><br><span class="line"><span class="keyword">typedef</span> myStruct defMyStruct;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span> <span class="title">object</span> <span class="title">defMyObject</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span> <span class="title">defMyStruct</span>;</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">object</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> object defMyObject;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> myStruct defMyStruct;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>将文件内容全部读出（包括回车符）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">Read_Image</span><span class="params">(<span class="keyword">const</span> std::string &amp;_csImagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(_csImagePath.c_str(), std::ios::in)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> iBufSize = <span class="number">0</span>;</span><br><span class="line">    std::string sFileContent = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> letter;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        std::string sContent;</span><br><span class="line">        <span class="keyword">while</span> (file.<span class="built_in">get</span>(letter))</span><br><span class="line">        &#123;</span><br><span class="line">            iBufSize += <span class="number">1</span>;</span><br><span class="line">            sFileContent += letter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sFileContent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Windows平台<code>运行时库</code>各选项说明</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/MD    使此应用程序使用特定于多线程和 DLL 的运行库版本。 定义 _MT 和 _DLL，并使编译器将库名 MSVCRT.lib 放入 .obj 文件中。</span><br><span class="line">    用此选项编译的应用程序静态链接到 MSVCRT.lib。 此库提供使链接器能够解析外部引用的代码的层。 实际工作代码包含在 </span><br><span class="line">    MSVCR versionnumber.DLL，该代码必须可运行时提供给与 MSVCRT.lib 链接的应用程序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/MDd    定义 _DEBUG、_MT 和 _DLL，并使此应用程序使用特定于多线程和 DLL 的调试版本的运行库。 它还会让编译器将库 </span><br><span class="line">        MSVCRTD.lib 放入 .obj 文件中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/MT    使此应用程序使用运行库的多线程的静态版本。 定义 _MT，并使编译器将库名 LIBCMT.lib 放入 .obj 文件中，以便链接器                 LIBCMT.lib 解析外部符号。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/MTd    定义 _DEBUG 和 _MT。 此选项还会让编译器将库名称 LIBCMTD.lib 放置到 .obj 文件中，以便链接器将使用 LIBCMTD.lib 来            解析外部符号。</span><br><span class="line"></span><br><span class="line">/LD    创建一个 DLL。将 /DLL 选项传递给链接器。 链接器查找 DllMain 函数，但并不需要该函数。 如果没有编写 DllMain 函数，则链接      器将插入返回 TRUE 的 DllMain 函数。链接 DLL 启动代码。如果未在命令行上指定导出 (.exp) 文件，则创建导入库 (.lib)。 将导       入库链接到调用 DLL 的应用程序。将 /Fe (NAME EXE) 解释为命名 DLL，而不是.exe文件。 默认情况下，程序名称变</span><br><span class="line">    basename.dll 而不是 basename.exe。</span><br><span class="line">    表示 /MT， 除非显式指定 /MD。</span><br><span class="line"></span><br><span class="line">/LDd    创建调试 DLL。 定义 _MT 和 _DEBUG。</span><br></pre></td></tr></table></figure>

<p>Windows平台的单线程和多线程运行库的区别在于，以前系统库有分只能用于单线程应用程序的库和可以跑在多线程模式下的库，所以在连接的时候需要指定单线程还是多线程。目前单线程选项已经弃用。</p>
<ol start="8">
<li><p><strong>虽然C++的编译器对变量有默认的初始化（默认都是初始化0），但是在声明变量的时候一定要显式地赋值，这并不代表不赋值会造成编译或者运行错误，而是这是一个良好的习惯，帮助你注意到每一个变量，注意结构体中每一个成员变量！！！</strong></p>
</li>
<li><p><code>lambda</code>按值默认捕获 <code>[=]</code> 变量捕获只能针对于在创建<code>lambda</code>式的作用域内可见的非静态局部变量（包括形参）；静态变量对与lambda本身就是不用捕获就可以访问，所以如果只是想捕获其当前值，需要明确写出拷贝并且按值捕获这个拷贝，代码如下：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_state = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> iState = g_state;</span><br><span class="line">filters.<span class="built_in">emplace_back</span>([iState](<span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value % g_state;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14 起的写法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_state = <span class="number">1</span>;</span><br><span class="line">filters.<span class="built_in">emplace_back</span>([g_state = g_state](<span class="keyword">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> value % g_state;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><code>lambda</code> 使用初始化捕获将对象移入闭包</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 此处将局部变量使用移动构造，移入到匿名函数中，节省了拷贝开销, 实际上 C++14 中lambda可以全面替代std::bind</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; data = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>([](<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;&amp; data) &#123; ... &#125;, std::<span class="built_in">move</span>(data));</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++14起</span></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; data = &#123; ... &#125;;</span><br><span class="line"><span class="keyword">auto</span> func = [data = std::<span class="built_in">move</span>(data)]() &#123;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li><strong>SDL</strong>库中<strong>SDL_Event</strong>是一个很精妙的联合结构（<strong>union</strong>）, 众所周知，<strong>union</strong>（联合）同时只能初始化一个成员。但是在使用过程中，我们却可以同时访问它的 <strong>type</strong> 成员 和 其他一个事件结构体。代码如下：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SDL_Event user_event;</span><br><span class="line"></span><br><span class="line">user_event.type = SDL_USEREVENT;</span><br><span class="line">user_event.user.code = <span class="number">2</span>;</span><br><span class="line">user_event.user.data1 = <span class="literal">NULL</span>;</span><br><span class="line">user_event.user.data2 = <span class="literal">NULL</span>;</span><br><span class="line">SDL_PushEvent(&amp;user_event);</span><br></pre></td></tr></table></figure>

<p>​    可以这样做的原因是因为 <strong>SDL_Event</strong> 其他事件结构体都统一的将第一个成员声明为 <strong>Uint32 type</strong> ,  这样直接访问 <strong>SDL_Event.type</strong> 就可以访问到对应事件结构体的 <strong>type</strong> 成员。其他的事件结构体例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  \brief Keyboard button event structure (event.key.*)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDL_KeyboardEvent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Uint32 type;        <span class="comment">/**&lt; ::SDL_KEYDOWN or ::SDL_KEYUP */</span></span><br><span class="line">    Uint32 timestamp;   <span class="comment">/**&lt; In milliseconds, populated using SDL_GetTicks() */</span></span><br><span class="line">    Uint32 windowID;    <span class="comment">/**&lt; The window with keyboard focus, if any */</span></span><br><span class="line">    Uint8 state;        <span class="comment">/**&lt; ::SDL_PRESSED or ::SDL_RELEASED */</span></span><br><span class="line">    Uint8 repeat;       <span class="comment">/**&lt; Non-zero if this is a key repeat */</span></span><br><span class="line">    Uint8 padding2;</span><br><span class="line">    Uint8 padding3;</span><br><span class="line">    SDL_Keysym keysym;  <span class="comment">/**&lt; The key that was pressed or released */</span></span><br><span class="line">&#125; SDL_KeyboardEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  \brief Mouse motion event structure (event.motion.*)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDL_MouseMotionEvent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Uint32 type;        <span class="comment">/**&lt; ::SDL_MOUSEMOTION */</span></span><br><span class="line">    Uint32 timestamp;   <span class="comment">/**&lt; In milliseconds, populated using SDL_GetTicks() */</span></span><br><span class="line">    Uint32 windowID;    <span class="comment">/**&lt; The window with mouse focus, if any */</span></span><br><span class="line">    Uint32 which;       <span class="comment">/**&lt; The mouse instance id, or SDL_TOUCH_MOUSEID */</span></span><br><span class="line">    Uint32 state;       <span class="comment">/**&lt; The current button state */</span></span><br><span class="line">    Sint32 x;           <span class="comment">/**&lt; X coordinate, relative to window */</span></span><br><span class="line">    Sint32 y;           <span class="comment">/**&lt; Y coordinate, relative to window */</span></span><br><span class="line">    Sint32 xrel;        <span class="comment">/**&lt; The relative motion in the X direction */</span></span><br><span class="line">    Sint32 yrel;        <span class="comment">/**&lt; The relative motion in the Y direction */</span></span><br><span class="line">&#125; SDL_MouseMotionEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SDL_Event 结构如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">SDL_Event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Uint32 type;                            <span class="comment">/**&lt; Event type, shared with all events */</span></span><br><span class="line">    SDL_CommonEvent common;                 <span class="comment">/**&lt; Common event data */</span></span><br><span class="line">    SDL_DisplayEvent display;               <span class="comment">/**&lt; Display event data */</span></span><br><span class="line">    ...;</span><br><span class="line">    Uint8 padding[<span class="keyword">sizeof</span>(<span class="keyword">void</span> *) &lt;= <span class="number">8</span> ? <span class="number">56</span> : <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) == <span class="number">16</span> ? <span class="number">64</span> : <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)];</span><br><span class="line">&#125; SDL_Event;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>​    MinGW 编译windows 静态库参数：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-static -static-libgcc -static-libstdc++</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>MSVC 编译器编译的程序 依赖 MSVCXXX.dll 等 Windows 系统运行库.  如果不想依赖, <code>代码生成</code> 选项使用 <code>\MT</code>.  CMake 构建下添加如下脚本:</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_property</span>(<span class="keyword">TARGET</span> d3d9_render PROPERTY MSVC_RUNTIME_LIBRARY <span class="string">&quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="14">
<li><p>std::string 与 std::wstring 相互转换. <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/cpp/text/how-to-convert-between-various-string-types?redirectedfrom=MSDN&view=msvc-170">参考链接</a></p>
</li>
<li><p><code>CMake</code> 在使用 <code>MSVC</code>编译器时, 使用 <code>utf-8</code>编码格式</p>
</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MSVC)</span><br><span class="line">    <span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/source-charset:utf-8&gt;&quot;</span>)</span><br><span class="line">    <span class="keyword">add_compile_options</span>(<span class="string">&quot;$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/source-charset:utf-8&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<ol start="16">
<li>Linux 编译链接三方库时，需要警惕系统库里是否同样有这个库，如果存在可能会导致在程序编译的时候真正链接的是系统路径的库而不是那我们真正想要的库。比较直接的链接方式是：使用 ldd 命令查看程序依赖那些动态库</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://github.com/mingxingren/2021/08/06/GLib%20and%20GTK3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mingxingren/images/avatar01.png">
      <meta itemprop="name" content="mingxingren">
      <meta itemprop="description" content="挖一口自己的井">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mingxingren的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/mingxingren/2021/08/06/GLib%20and%20GTK3/" class="post-title-link" itemprop="url">GLib和GTK3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-06 19:00:00" itemprop="dateCreated datePublished" datetime="2021-08-06T19:00:00+08:00">2021-08-06</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-27 20:28:10" itemprop="dateModified" datetime="2022-03-27T20:28:10+08:00">2022-03-27</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>该篇为我学习GLib 和 GTK 的笔记，只是记录一些知识点和写法，若碰巧浏览此篇，尽量不要以此篇为准！</p>
</blockquote>
<h2 id="GLib相关介绍"><a href="#GLib相关介绍" class="headerlink" title="GLib相关介绍"></a>GLib相关介绍</h2><h3 id="GObject"><a href="#GObject" class="headerlink" title="GObject"></a>GObject</h3><hr>
<h4 id="GObject简单声明定义"><a href="#GObject简单声明定义" class="headerlink" title="GObject简单声明定义"></a>GObject简单声明定义</h4><p>GObject实现中， 类是两个结构体的组合，一个是<strong>实例结构体</strong>（保存所有对象私有数据），另一个是<strong>类结构体</strong>（保存所有对象共享的数据），其结构关系图如下：</p>
<p><img src="https://github.com/mingxingren/Notes/raw/master/resource/photo/image-2021080601.png" alt="image-01"></p>
<h4 id="GObject-构造和析构大致过程"><a href="#GObject-构造和析构大致过程" class="headerlink" title="GObject 构造和析构大致过程"></a>GObject 构造和析构大致过程</h4><p>构造过程：</p>
<ul>
<li>注册 <strong>GObject</strong> 类型到类型系统，此操作是在执行 <strong>main</strong> 函数之前，<strong>glib</strong>初始化过程中完成的</li>
<li>分配内存给 <strong>GObjectClass</strong> 和 <strong>GObject  structure</strong></li>
<li>初始化 <strong>GObjectClass</strong> 结构体内存，这块内存是对象的类（类似C++类中的函数和静态变量）</li>
<li>初始化 <strong>GObject structure</strong> 内存， 这块内存属于实例</li>
</ul>
<p>注意：初始化流程是在第一次调用 <strong>g_object_new</strong> 函数时进行的。在第二次后续调用 <strong>g_object_new</strong>时，它只执行两步：</p>
<p>① 给 <strong>GObject structure</strong> 分配内存</p>
<p>② 初始化内存</p>
<p>析构过程：销毁 <strong>GObject</strong> 实例，内存释放，但是不会销毁 <strong>GObjectClass</strong>，即使所有<strong>GObject</strong>实例被回收，<strong>GObjectClass</strong>仍然存在</p>
<p>样例声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dlist.h 实现一个列表类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glib-object.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PM_TYPE_DLIST (pm_dlist_get_type())</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PMDListNode</span> <span class="title">PMDListNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">PMDListNode</span> &#123;</span></span><br><span class="line">        PMDListNode *prev;</span><br><span class="line">        PMDListNode *next;</span><br><span class="line">        <span class="keyword">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PMDList</span> <span class="title">PMDList</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  _<span class="title">PMDList</span> &#123;</span></span><br><span class="line">        GObject parent_instance;</span><br><span class="line">        PMDListNode *head;</span><br><span class="line">        PMDListNode *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PMDListClass</span> <span class="title">PMDListClass</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">PMDListClass</span> &#123;</span></span><br><span class="line">        GObjectClass parent_class;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">GType <span class="title">pm_dlist_get_type</span> <span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dlist.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;dlist.h&quot;</span></span></span><br><span class="line"><span class="comment">// 对 pm_dlist_get_type 生成实现，返回类对象</span></span><br><span class="line"><span class="comment">// #arg_1: 类名 	#arg_2: 成员函数命名前缀	#arg_3: 父类型</span></span><br><span class="line">G_DEFINE_TYPE (PMDList, pm_dlist, G_TYPE_OBJECT);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pm_dlist_init</span> <span class="params">(PMDList *self)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        g_printf (<span class="string">&quot;\t实例结构体初始化！\n&quot;</span>);</span><br><span class="line">        self-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">        self-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pm_dlist_class_init</span> <span class="params">(PMDListClass *klass)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        g_printf (<span class="string">&quot;类结构体初始化!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GObject具有功能：</p>
<ul>
<li><p>基于引用计数的内存管理 —— 结合 <strong>g_object_ref</strong> 和 <strong>g_object_unref</strong> 两个函数对引用计数进行加减</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> g_object_ref(Obj) ((glib_typeof (Obj)) (g_object_ref) (Obj))</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_object_unref</span> <span class="params">(gpointer object)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>对象的构造函数与析构函数</p>
</li>
<li><p>可设置对象属性的 set/get 函数</p>
</li>
<li><p>易于使用的信号机制</p>
</li>
</ul>
<p>继承GObject基类的实例化代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PMDList *dlist; <span class="comment">/* 类的实例化，产生对象 */</span></span><br><span class="line">dlist = g_object_new (PM_TYPE_DLIST, <span class="literal">NULL</span>); <span class="comment">/* 创建对象的一个实例 并将其引用计数 +1 */</span></span><br><span class="line">g_object_unref (dlist); <span class="comment">/* 将对象的实例引用计数 -1，并检测对象的实例的引用计数是否为 0，若为 0，那么便释放对象的实例的存储空间。 */</span></span><br><span class="line">dlist = g_object_new (PM_TYPE_DLIST, <span class="literal">NULL</span>); <span class="comment">/* 再创建对象的一个实例 */</span></span><br></pre></td></tr></table></figure>



<p>GObject子类化完整的过程：</p>
<blockquote>
<p>① 在 .h 文件中包含 glib-object.h；<br>② 在 .h 文件中构建实例结构体与类结构体，并分别将 GObject 类的实例结构体与类结构体置于成员之首；<br>③ 在 .h 文件中定义 P_TYPE_T 宏，并声明 p_t_get_type 函数；<br>④ 在 .c 文件中调用 G_DEFINE_TYPE 宏产生类型注册代码。</p>
</blockquote>
<p>声明的简单范例，参考地址： <a target="_blank" rel="noopener" href="https://blog.csdn.net/knowledgebao/article/details/82418046">https://blog.csdn.net/knowledgebao/article/details/82418046</a></p>
<p><a href="https://github.com/ToshioCP/Gobject-tutorial/blob/main/gfm/sec2.md">https://github.com/ToshioCP/Gobject-tutorial/blob/main/gfm/sec2.md</a></p>
<h4 id="GObject-设置属性"><a href="#GObject-设置属性" class="headerlink" title="GObject 设置属性"></a>GObject 设置属性</h4><h4 id="GObject-的继承"><a href="#GObject-的继承" class="headerlink" title="GObject 的继承"></a>GObject 的继承</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kb-Son.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kb-Parent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KbSon</span> <span class="title">KbSon</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KbSon</span> &#123;</span></span><br><span class="line">        KbParent parent;	<span class="comment">// 继承父实例属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KbSonClass</span> <span class="title">KbSonClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">KParentClass</span> &#123;</span></span><br><span class="line">        KbParentClass parent_class;	<span class="comment">// 继承父类属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kb-Son.c</span></span><br><span class="line">...</span><br><span class="line">G_DEFINE_TYPE(KbSon, kb_son, KB_TYPE_Parent);	<span class="comment">// GType 设置成父类 其他代码一样</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>继承常用的宏（其中P表示项目名称     T表示类名称    PTPrivate表示私有数据结构体）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_TYPE_T (p_t_get_type())	<span class="comment">// 仅在使用 g_object_new 进行对象实例化的时候使用一次，用于向 GObject 库的类型系统注册 PT 类</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_T(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), P_TYPE_T, PT))	<span class="comment">// 用于将 obj 对象的类型强制转换为 P_T 类的实例结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_IS_T(obj) G_TYPE_CHECK_INSTANCE_TYPE((obj), P_TYPE_T)) <span class="comment">// 用于判断 obj 对象的类型是否为 P_T 类的实例结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_T_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), P_TYPE_T, PTClass))<span class="comment">// 用于将 kclass 类结构体得类型强制转换为 P_T 类的类结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_IS_T_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), P_TYPE_T))	<span class="comment">// 用于判断 klass 类结构体的类型是否为 P_T 类的类结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_T_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS((obj), P_TYPE_T, PTClass))	<span class="comment">// 获取 obj 对象对应的类结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_T_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE((obj), P_TYPE_T, PTPrivate))	<span class="comment">// 获取 obj 对象对应的私有数据</span></span></span><br></pre></td></tr></table></figure>



<p>接口常用的宏（其中 P 表示项目名称    T表示类名称    I是接口的缩写）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_TYPE_IT (p_t_get_type())	<span class="comment">// 仅在接口实现时使用一次，用于向 GObject 库的类型系统注册 PIT 接口</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_IT(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), P_TYPE_IT, P_IT))	<span class="comment">// 用于将 obj 对象的类型强制转换为 P_IT 接口的实例结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_IS_IT(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), P_TYPE_IT))	<span class="comment">// 用于判断 obj 对象是否为 P_IT接口的实例结构体类型</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P_IT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), P_TYPE_IT, P_IT))	<span class="comment">// 获取 obj 对象对应的 P_IT 接口的类结构体类型</span></span></span><br></pre></td></tr></table></figure>



<h4 id="GObject-的信号使用"><a href="#GObject-的信号使用" class="headerlink" title="GObject 的信号使用"></a>GObject 的信号使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建信号</span></span><br><span class="line"><span class="function">guint <span class="title">g_signal_new</span> <span class="params">(<span class="keyword">const</span> gchar		*signal_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                    GType				   itype,</span></span></span><br><span class="line"><span class="params"><span class="function">                    GSignalFlags	signal_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                    guint           class_offset,</span></span></span><br><span class="line"><span class="params"><span class="function">                    GSignalAccumulator	 		accumulator,</span></span></span><br><span class="line"><span class="params"><span class="function">                    gpointer		 			accu_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                    GSignalCMarshaller  		c_marshaller,</span></span></span><br><span class="line"><span class="params"><span class="function">                    GType               		return_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                    guint               		n_params,</span></span></span><br><span class="line"><span class="params"><span class="function">                    ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接信号和回调函数</span></span><br><span class="line"><span class="function">gulong <span class="title">g_signal_connect_data</span> <span class="params">(gpointer	instance, <span class="keyword">const</span> gchar	*detailed_signal,</span></span></span><br><span class="line"><span class="params"><span class="function">                              GCallback	  			c_handler,</span></span></span><br><span class="line"><span class="params"><span class="function">                              gpointer		  			 data,</span></span></span><br><span class="line"><span class="params"><span class="function">                              GClosureNotify	 destroy_data,</span></span></span><br><span class="line"><span class="params"><span class="function">                              GConnectFlags	  	 connect_flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发射信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g_signal_emit_by_name</span> <span class="params">(gpointer	instance, <span class="keyword">const</span> gchar	*detailed_signal, ...)</span></span>;</span><br></pre></td></tr></table></figure>





<h2 id="GTK"><a href="#GTK" class="headerlink" title="GTK"></a>GTK</h2><p><strong>GtkApplication</strong></p>
<p>用于处理GTK+初始化、应用程序唯一性、会话管理，通过导出操作和菜单提供一些基本的脚本能力和桌面shell集成，并管理一个顶级窗口列表，其生命周期自动绑定到应用程序的生命周期。</p>
<p><strong>GtkWindow</strong></p>
<p>一个 <strong>GtkWindow</strong> 是一个可以包含其他控件的顶级窗口，窗口通常在桌面系统下具有样式。并且允许用户放缩、移动或者关闭窗体等操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示窗体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gtk_window_present</span> <span class="params">(GtkWindow* window)</span></span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/mingxingren/page/2/">2</a><a class="extend next" rel="next" href="/mingxingren/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mingxingren</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/mingxingren/js/comments.js"></script><script src="/mingxingren/js/utils.js"></script><script src="/mingxingren/js/motion.js"></script><script src="/mingxingren/js/next-boot.js"></script>

  
<script src="/mingxingren/js/third-party/search/local-search.js"></script>




  





</body>
</html>
